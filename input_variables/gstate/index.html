<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="The Abinit group">
    <link rel="canonical" href="http://www.abinit.org/input_variables/gstate/">
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Ground-State - abinit</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <link href="../../css/codehilite.css" rel="stylesheet">
    <link href="../../css/extra.css" rel="stylesheet">
    
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <!-- <script src="../../js/somelib.js"></script> -->

    <!-- Jquery from Google CDN 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    -->

    <!-- Bootstrap http://getbootstrap.com/getting-started/ -->
    <!-- Latest compiled and minified CSS 

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    -->
    <!-- Optional theme

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
    -->
    <!-- Latest compiled and minified JavaScript

    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    -->

    <!-- MathJax support -->
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script> 
    <!--
    <script type="text/javascript" async 
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_SVG">
    </script> 
    -->

    <!--
    Configure MathJax to produce automatic equation numbers
    http://docs.mathjax.org/en/latest/tex.html
    -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          TeX: {
              equationNumbers: { autoNumber: "all" },
              extensions: ["AMSmath.js"],
              Macros: {
                  rr: "{\\bf r}",
                  GG: "{\\bf G}",
                  kk: "{\\bf k}",
                  qq: "{\\bf q}"
              }
          }
      });
    </script>

    <!-- See http://docs.mathjax.org/en/latest/start.html 
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        extensions: ["tex2jax.js", "MathMenu.js", "MathZoom.js"],
        jax: ["input/TeX", "output/HTML-CSS", "output/NativeMML],
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>
    -->


    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "algalch", url: "#algalch", children: [
          ]},
          {title: "boxcenter", url: "#boxcenter", children: [
          ]},
          {title: "boxcutmin", url: "#boxcutmin", children: [
          ]},
          {title: "charge", url: "#charge", children: [
          ]},
          {title: "chkexit", url: "#chkexit", children: [
          ]},
          {title: "chkprim", url: "#chkprim", children: [
          ]},
          {title: "chksymbreak", url: "#chksymbreak", children: [
          ]},
          {title: "cpuh", url: "#cpuh", children: [
          ]},
          {title: "cpum", url: "#cpum", children: [
          ]},
          {title: "cpus", url: "#cpus", children: [
          ]},
          {title: "diecut", url: "#diecut", children: [
          ]},
          {title: "diegap", url: "#diegap", children: [
          ]},
          {title: "dielam", url: "#dielam", children: [
          ]},
          {title: "dielng", url: "#dielng", children: [
          ]},
          {title: "diemac", url: "#diemac", children: [
          ]},
          {title: "diemix", url: "#diemix", children: [
          ]},
          {title: "diemixmag", url: "#diemixmag", children: [
          ]},
          {title: "dosdeltae", url: "#dosdeltae", children: [
          ]},
          {title: "enunit", url: "#enunit", children: [
          ]},
          {title: "fband", url: "#fband", children: [
          ]},
          {title: "iatsph", url: "#iatsph", children: [
          ]},
          {title: "icoulomb", url: "#icoulomb", children: [
          ]},
          {title: "iprcel", url: "#iprcel", children: [
          ]},
          {title: "iqpt", url: "#iqpt", children: [
          ]},
          {title: "ixcpositron", url: "#ixcpositron", children: [
          ]},
          {title: "jellslab", url: "#jellslab", children: [
          ]},
          {title: "kptbounds", url: "#kptbounds", children: [
          ]},
          {title: "kptrlatt", url: "#kptrlatt", children: [
          ]},
          {title: "kptrlen", url: "#kptrlen", children: [
          ]},
          {title: "magcon_lambda", url: "#magcon_lambda", children: [
          ]},
          {title: "magconon", url: "#magconon", children: [
          ]},
          {title: "mixalch", url: "#mixalch", children: [
          ]},
          {title: "natsph", url: "#natsph", children: [
          ]},
          {title: "natsph_extra", url: "#natsph_extra", children: [
          ]},
          {title: "nbdbuf", url: "#nbdbuf", children: [
          ]},
          {title: "ndivk", url: "#ndivk", children: [
          ]},
          {title: "ndivsm", url: "#ndivsm", children: [
          ]},
          {title: "ngfft", url: "#ngfft", children: [
          ]},
          {title: "ngqpt", url: "#ngqpt", children: [
          ]},
          {title: "nline", url: "#nline", children: [
          ]},
          {title: "npsp", url: "#npsp", children: [
          ]},
          {title: "npspalch", url: "#npspalch", children: [
          ]},
          {title: "nqpt", url: "#nqpt", children: [
          ]},
          {title: "nshiftq", url: "#nshiftq", children: [
          ]},
          {title: "nspden", url: "#nspden", children: [
          ]},
          {title: "nspinor", url: "#nspinor", children: [
          ]},
          {title: "ntypalch", url: "#ntypalch", children: [
          ]},
          {title: "ntyppure", url: "#ntyppure", children: [
          ]},
          {title: "nucdipmom", url: "#nucdipmom", children: [
          ]},
          {title: "nwfshist", url: "#nwfshist", children: [
          ]},
          {title: "occ", url: "#occ", children: [
          ]},
          {title: "optdriver", url: "#optdriver", children: [
          ]},
          {title: "optstress", url: "#optstress", children: [
          ]},
          {title: "posdoppler", url: "#posdoppler", children: [
          ]},
          {title: "positron", url: "#positron", children: [
          ]},
          {title: "posnstep", url: "#posnstep", children: [
          ]},
          {title: "posocc", url: "#posocc", children: [
          ]},
          {title: "postoldfe", url: "#postoldfe", children: [
          ]},
          {title: "postoldff", url: "#postoldff", children: [
          ]},
          {title: "prtdensph", url: "#prtdensph", children: [
          ]},
          {title: "prtebands", url: "#prtebands", children: [
          ]},
          {title: "qpt", url: "#qpt", children: [
          ]},
          {title: "qptnrm", url: "#qptnrm", children: [
          ]},
          {title: "qptopt", url: "#qptopt", children: [
          ]},
          {title: "qptrlatt", url: "#qptrlatt", children: [
          ]},
          {title: "ratsph", url: "#ratsph", children: [
          ]},
          {title: "ratsph_extra", url: "#ratsph_extra", children: [
          ]},
          {title: "scphon_supercell", url: "#scphon_supercell", children: [
          ]},
          {title: "scphon_temp", url: "#scphon_temp", children: [
          ]},
          {title: "shiftq", url: "#shiftq", children: [
          ]},
          {title: "slabwsrad", url: "#slabwsrad", children: [
          ]},
          {title: "slabzbeg", url: "#slabzbeg", children: [
          ]},
          {title: "slabzend", url: "#slabzend", children: [
          ]},
          {title: "so_psp", url: "#so_psp", children: [
          ]},
          {title: "spinat", url: "#spinat", children: [
          ]},
          {title: "stmbias", url: "#stmbias", children: [
          ]},
          {title: "symafm", url: "#symafm", children: [
          ]},
          {title: "timopt", url: "#timopt", children: [
          ]},
          {title: "tl_nprccg", url: "#tl_nprccg", children: [
          ]},
          {title: "tl_radius", url: "#tl_radius", children: [
          ]},
          {title: "tphysel", url: "#tphysel", children: [
          ]},
          {title: "tsmear", url: "#tsmear", children: [
          ]},
          {title: "usekden", url: "#usekden", children: [
          ]},
          {title: "vacuum", url: "#vacuum", children: [
          ]},
          {title: "vacwidth", url: "#vacwidth", children: [
          ]},
          {title: "wtq", url: "#wtq", children: [
          ]},
          {title: "wvl_bigdft_comp", url: "#wvl_bigdft_comp", children: [
          ]},
          {title: "wvl_crmult", url: "#wvl_crmult", children: [
          ]},
          {title: "wvl_frmult", url: "#wvl_frmult", children: [
          ]},
          {title: "wvl_ngauss", url: "#wvl_ngauss", children: [
          ]},
          {title: "wvl_nprccg", url: "#wvl_nprccg", children: [
          ]},
          {title: "xredsph_extra", url: "#xredsph_extra", children: [
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.8/ace.js"></script>
      <script src="../../extra_javascript/abidocs.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../gw/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../gw/" class="btn btn-xs btn-link">
        GW
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../geo/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../geo/" class="btn btn-xs btn-link">
        Geometry
      </a>
    </div>
    
  </div>

    

    <!-- Return to Top -->

<p><a href="javascript:" id="return-to-top"><i class="glyphicon glyphicon-chevron-up"></i></a></p>
<h2 id="algalch"><strong>algalch</strong><a class="headerlink" href="#algalch" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> ALGorithm for generating ALCHemical pseudopotentials<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/AtomTypes">AtomTypes</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (<a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a>)<br />
<em>Default value:</em> *1<br />
Test list:</p>
<ul>
<li>v3:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t92.in" title="Linear chain of X2 molecules (2 atoms per unit cell), using alchemical atoms (well,  with no mixing,  just for a test) Computation of the second derivative of the total energy with respect to a atomic displacement perpendicular to the chain,  with q(0 0 1/2) wavevector. The first psp is Si,  the second one is Ge,  but the mixing coefficients are 1.0 and 0.0 . See test 4 of v2,  except with alchemy.">tests/v3/Input/t92.in</a></li>
</ul>
<p>Used for the generation of alchemical pseudopotentials, that is, when
<a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a> is non-zero.</p>
<p>Give the algorithm to be used to generate the <a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a> alchemical
potentials from the different <a class="wikilink" href="../../input_variables/gstate/#npspalch">npspalch</a> pseudopotentials dedicated to this
use.</p>
<p>Presently, <a class="wikilink" href="../../input_variables/gstate/#algalch">algalch</a> can only have the value 1, that is :</p>
<ul>
<li>the local potentials are mixed, thanks to the <a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a> mixing coefficients </li>
<li>the form factors of the non-local projectors are all preserved, and all considered to generate the alchemical potential </li>
<li>the scalar coefficients of the non-local projectors are multiplied by the proportion of the corresponding type of atom that is present in <a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a> </li>
<li>the characteristic radius for the core charge is a linear combination of the characteristic radii of the core charges, build with the <a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a> mixing coefficients </li>
<li>the core charge function f(r/rc) is a linear combination of the core charge functions, build with the <a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a> mixing coefficients </li>
</ul>
<p>Later, other algorithms for the mixing might be included.</p>
<p>Note that alchemical mixing cannot be used with PAW.</p>
<hr />
<h2 id="boxcenter"><strong>boxcenter</strong><a class="headerlink" href="#boxcenter" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> BOX CENTER<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/TDDFT">TDDFT</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> (3)<br />
<em>Default value:</em> [0.5, 0.5, 0.5]  </p>
<p>Defines the center of the box, in reduced coordinates. At present, this
information is only used in the case of Time-Dependent DFT computation of the
oscillator strength. One must take boxcenter such as to be roughly the center
of the cluster or molecule. The default is sensible when the vacuum
surrounding the cluster or molecule has xred 0 or 1. On the contrary, when the
cluster or molecule is close to the origin, it is better to take
<a class="wikilink" href="../../input_variables/gstate/#boxcenter">boxcenter</a>=(0 0 0).</p>
<hr />
<h2 id="boxcutmin"><strong>boxcutmin</strong><a class="headerlink" href="#boxcutmin" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> BOX CUT-off MINimum<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Planewaves">Planewaves</a>, <a class="wikilink" href="../../topics/TuningSpeed">TuningSpeed</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 2.0<br />
Test list:</p>
<ul>
<li>mpiio:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/mpiio/Input/t42.in" title="He FCC solid in conventional cell (4 atoms). Test the recursion algorithm (for high-temperature calculations). Only with 0 and 4 procs.">tests/mpiio/Input/t42.in</a></li>
<li>v3:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t43.in" title="No description available">tests/v3/Input/t43.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t75.in" title="Simple test for double grid (fine/coarse) system,  the cutting radius and the initial fermi energy in recursion method Corresponding variables: recgratio,  recrcut, recefermi respectively Corresponding code: 68_recursion Other test: paral/tT, v5/t76">tests/v5/Input/t75.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t76.in" title="Test for an electron gas by recursion method (Vtrial is set to zero) Corresponding variable: rectesteg Corresponding code: 68_recursion Other test: paral/tT, v5/t76">tests/v5/Input/t76.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t95.in" title="Computation of elastic tensor and internal strain in DFPT+PAW Ground state is computed. Finite-difference runs with strain component 1 (1def) is computed DFPT is computed Comparaison with Finite Diferrences give excellent agreement ~1e-5% DFPT is computed with usexcnhat==0 (Just for test)">tests/v7/Input/t95.in</a></li>
<li>v8:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v8/Input/t02.in" title="Geometry optimization with LBFGS">tests/v8/Input/t02.in</a></li>
</ul>
<p>The box cut-off ratio is the ratio between the wavefunction plane wave sphere
radius, and the radius of the sphere that can be inserted in the FFT box, in
reciprocal space. In order for the density to be exact (in the case of plane
wave, not PAW), this ratio should be at least two. If one uses a smaller
ratio, one will gain speed, at the expense of accuracy. In case of pure ground
state calculation (e.g. for the determination of geometries), this is
sensible. However, the wavefunctions that are obtained CANNOT be used for
starting response function calculation.</p>
<hr />
<h2 id="charge"><strong>charge</strong><a class="headerlink" href="#charge" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> CHARGE<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Coulomb">Coulomb</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0  </p>
<p>Used to establish charge balance between the number of electrons filling the
bands and the nominal <a class="wikilink" href="../../input_variables/gstate/#charge">charge</a> associated with the atomic cores.<br />
The code adds up the number of valence electrons provided by the
pseudopotentials of each type (call this "zval"), then add <a class="wikilink" href="../../input_variables/gstate/#charge">charge</a>, to get
the number of electrons per unit cell, <a class="wikilink" href="../../input_variables/internal/#nelect">nelect</a>.<br />
Then, if <a class="wikilink" href="../../input_variables/basic/#iscf">iscf</a> is positive, the code adds up the band occupancies (given in
array <a class="wikilink" href="../../input_variables/gstate/#occ">occ</a>) for all bands at each k point, then multiplies by the k point
weight <a class="wikilink" href="../../input_variables/basic/#wtk">wtk</a> at each k point. Call this sum "nelect_occ" (for the number of
electrons from occupation numbers). It is then required that:<br />
nelect_occ = nelect<br />
To treat a neutral system, which is desired in nearly all cases, one must use
<a class="wikilink" href="../../input_variables/gstate/#charge">charge</a>=0. To treat a system missing one electron per unit cell, set
<a class="wikilink" href="../../input_variables/gstate/#charge">charge</a>=+1.</p>
<hr />
<h2 id="chkexit"><strong>chkexit</strong><a class="headerlink" href="#chkexit" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> CHecK whether the user want to EXIT<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Control">Control</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0<br />
Test list:</p>
<ul>
<li>v1:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t97.in" title="8-atom Si cube,  fixed geometry,  with a large cut-off. The exit file is created. The job should stop after having initialized the wavefunctions.">tests/v1/Input/t97.in</a></li>
<li>v4:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v4/Input/t97.in" title="Test of molecular dynamics of B atoms,  in the isokinetic ensemble,  based on the Thomas-Fermi functional (very fast,  even with 32 atoms).">tests/v4/Input/t97.in</a></li>
</ul>
<p>If <a class="wikilink" href="../../input_variables/gstate/#chkexit">chkexit</a> is 1 or 2, ABINIT will check whether the user wants to
interrupt the run (using the keyword "exit" on the top of the input file or
creating a file named "abinit.exit": see the <a class="wikilink" href="../../input_variables/gstate/#chkexit">end of section 3.2</a>
of the <a class="wikilink" href="../../help_abinit/">help_abinit</a>).</p>
<p>If <a class="wikilink" href="../../input_variables/gstate/#chkexit">chkexit</a>=0, the check is not performed at all</p>
<p>If <a class="wikilink" href="../../input_variables/gstate/#chkexit">chkexit</a>=1, the check is not performed frequently (after each SCF step)</p>
<p>If <a class="wikilink" href="../../input_variables/gstate/#chkexit">chkexit</a>=2, the check is performed frequently (after a few bands, at
each k point)</p>
<p>In all cases, the check is performed at most every 2 seconds of CPU time.</p>
<hr />
<h2 id="chkprim"><strong>chkprim</strong><a class="headerlink" href="#chkprim" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> CHecK whether the cell is PRIMitive<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/crystal">crystal</a>, <a class="wikilink" href="../../topics/UnitCell">UnitCell</a>, <a class="wikilink" href="../../topics/SmartSymm">SmartSymm</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1  </p>
<p>If the symmetry finder is used (see <a class="wikilink" href="../../input_variables/basic/#nsym">nsym</a>), a non-zero value of <a class="wikilink" href="../../input_variables/gstate/#chkprim">chkprim</a>
will make the code stop if a non-primitive cell is used. If <a class="wikilink" href="../../input_variables/gstate/#chkprim">chkprim</a>=0, a
warning is issued, but the run does not stop.</p>
<p>If you are generating the atomic and cell geometry using <a class="wikilink" href="../../input_variables/geo/#spgroup">spgroup</a>, you
might generate a PRIMITIVE cell using <a class="wikilink" href="../../input_variables/geo/#brvltt">brvltt</a>=-1 .</p>
<hr />
<h2 id="chksymbreak"><strong>chksymbreak</strong><a class="headerlink" href="#chksymbreak" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> CHecK SYMmetry BREAKing<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/k-points">k-points</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1  </p>
<p>This variable governs the behaviour of the code when there are potential
source of symmetry breaking, related e.g. to the k point grid or the presence
of non-symmorphic translations which might not be coherent with the exchange-
correlation grid.</p>
<p>When <a class="wikilink" href="../../input_variables/gstate/#chksymbreak">chksymbreak</a>=1, the code stops (or issue a warning) if :</p>
<ul>
<li>(1) The k point grid is non-symmetric, in case <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> =1, 2, or 4 ; </li>
<li>(2) The non-symmorphic translation part of the symmetry operations has components that are not zero, or simple fractions, with 2, 3, 4, 6, 8 or 12 as denominators. </li>
</ul>
<p>When <a class="wikilink" href="../../input_variables/gstate/#chksymbreak">chksymbreak</a> is zero, there is no such check.<br />
When <a class="wikilink" href="../../input_variables/gstate/#chksymbreak">chksymbreak</a> is minus 1, the code stops if the condition (1) is met,
but in case the condition (2) is met, there will be a trial to shift the
atomic coordinates such as to obtain symmetry operations with the adequate
non-symmorphic part.</p>
<p>Explanation :<br />
In the ground-state calculation, such breaking of the symmetry is usually
harmless. However, if the user is doing a calculation of phonons using DFPT
(<a class="wikilink" href="../../input_variables/dfpt/#rfphon">rfphon</a>=1), the convergence with respect to the number of k points will be
much worse with a non-symmetric grid than with a symmetric one. Also, if the
user is doing a GW calculation, the presence of non-symmorphic translations
that are not coherent with the FFT grid might cause problems. In the GW part,
indeed, one needs to reconstruct the wavefunctions in the full Brillouin zone
for calculating both the polarizability and the self-energy. The wavefunctions
in the full Brillouin zone are obtained from the irreducible wedge by applying
the symmetry operations of the space group of the crystal. In the present
implementation, the symmetrization of the wavefunctions is done in real space
on the FFT mesh that, therefore, has to be coherent both with the rotational
part as well as with the fractional translation of each symmetry operation. If
the condition (2) is met, the GW code will not be able to find a symmetry-
preserving FFT mesh.<br />
So, it was decided to warn the user about these possible problems already at
the level of the ground state calculations, although such warning might be
irrelevant.<br />
If you encounter a problem outlined above, you have two choices : change your
atomic positions (translate them) such that the origin appears as the most
symmetric point ; or ignore the problem, and set <a class="wikilink" href="../../input_variables/gstate/#chksymbreak">chksymbreak</a>=0 .</p>
<hr />
<h2 id="cpuh"><strong>cpuh</strong><a class="headerlink" href="#cpuh" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> CPU time limit in Hours<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Control">Control</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.0<br />
<em>The use of this variable forbids the use of:</em> specified(<a class="wikilink" href="../../input_variables/gstate/#cpum">cpum</a>) or specified(<a class="wikilink" href="../../input_variables/gstate/#cpus">cpus</a>)<br />
Test list:</p>
<p>Only one of the three real parameters <a class="wikilink" href="../../input_variables/gstate/#cpus">cpus</a>, <a class="wikilink" href="../../input_variables/gstate/#cpum">cpum</a> and <a class="wikilink" href="../../input_variables/gstate/#cpuh">cpuh</a> can be
defined in the input file to set up a CPU time limit. When the job reaches
that limit, it will try to end smoothly. However, note that this might still
take some time. If the user want a firm CPU time limit, the present parameter
must be reduced sufficiently. Intuition about the actual margin to be taken
into account should come with experience ...<br />
A zero value has no action of the job.</p>
<hr />
<h2 id="cpum"><strong>cpum</strong><a class="headerlink" href="#cpum" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> CPU time limit in Minutes<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Control">Control</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.0<br />
<em>The use of this variable forbids the use of:</em> specified(<a class="wikilink" href="../../input_variables/gstate/#cpum">cpum</a>) or specified(<a class="wikilink" href="../../input_variables/gstate/#cpus">cpus</a>)<br />
Test list:</p>
<p>Only one of the three real parameters <a class="wikilink" href="../../input_variables/gstate/#cpus">cpus</a>, <a class="wikilink" href="../../input_variables/gstate/#cpum">cpum</a> and <a class="wikilink" href="../../input_variables/gstate/#cpuh">cpuh</a> can be
defined in the input file to set up a CPU time limit. When the job reaches
that limit, it will try to end smoothly. However, note that this might still
take some time. If the user want a firm CPU time limit, the present parameter
must be reduced sufficiently. Intuition about the actual margin to be taken
into account should come with experience ...<br />
A zero value has no action of the job.</p>
<hr />
<h2 id="cpus"><strong>cpus</strong><a class="headerlink" href="#cpus" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> CPU time limit in seconds<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Control">Control</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.0<br />
<em>The use of this variable forbids the use of:</em> specified(<a class="wikilink" href="../../input_variables/gstate/#cpum">cpum</a>) or specified(<a class="wikilink" href="../../input_variables/gstate/#cpus">cpus</a>)<br />
Test list:</p>
<ul>
<li>tutoparal:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutoparal/Input/tgspw_01.in" title="Gold with one vacancy (107 atoms of gold).">tests/tutoparal/Input/tgspw_01.in</a></li>
<li>v1:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t98.in" title="8-atom Si cube,  fixed geometry,  with a large cut-off. A CPU time limit of 20 sec is required. The whole job would be 200 sec on a PPro at 200 MHz. Afterwards,  the job is restarted in run 99.">tests/v1/Input/t98.in</a></li>
<li>v4:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v4/Input/t89.in" title="Au linear chain. Test the output of a launch.dat file for WanT Note: the file that is produced is not tested, Only the usual output file of ABINIT. Want output does not support MPI with ncpus &gt; 1.">tests/v4/Input/t89.in</a></li>
</ul>
<p>Only one of the three real parameters <a class="wikilink" href="../../input_variables/gstate/#cpus">cpus</a>, <a class="wikilink" href="../../input_variables/gstate/#cpum">cpum</a> and <a class="wikilink" href="../../input_variables/gstate/#cpuh">cpuh</a> can be
defined in the input file to set up a CPU time limit. When the job reaches
that limit, it will try to end smoothly. However, note that this might still
take some time. If the user want a firm CPU time limit, the present parameter
must be reduced sufficiently. Intuition about the actual margin to be taken
into account should come with experience ...<br />
A zero value has no action of the job.</p>
<hr />
<h2 id="diecut"><strong>diecut</strong><a class="headerlink" href="#diecut" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> DIElectric matrix energy CUToff<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/SCFAlgorithms">SCFAlgorithms</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 2.2  </p>
<p>Kinetic energy cutoff that controls the number of planewaves used to represent
the dielectric matrix:<br />
(1/2)[(2 Pi)*(Gmax)]  2  =<a class="wikilink" href="../../input_variables/basic/#ecut">ecut</a> for Gmax.<br />
Can be specified in Ha (the default), Ry, eV or Kelvin, since <a class="wikilink" href="../../input_variables/gstate/#diecut">diecut</a> has
the '<a class="wikilink" href="../../ENERGY/">ENERGY</a>' characteristics. (1 Ha=27.2113845 eV)<br />
All planewaves inside this "basis sphere" centered at G=0 are included in the
basis. This is useful only when <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a>&gt;=21, which means that a
preconditioning scheme based on the dielectric matrix is used.<br />
NOTE : a negative <a class="wikilink" href="../../input_variables/gstate/#diecut">diecut</a> will define the same dielectric basis sphere as
the corresponding positive value, but the FFT grid will be identical to the
one used for the wavefunctions. The much smaller FFT grid, used when
<a class="wikilink" href="../../input_variables/gstate/#diecut">diecut</a> is positive, gives exactly the same results.<br />
No meaning for RF calculations yet.</p>
<hr />
<h2 id="diegap"><strong>diegap</strong><a class="headerlink" href="#diegap" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> DIElectric matrix GAP<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/SCFAlgorithms">SCFAlgorithms</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.1<br />
Test list:</p>
<ul>
<li>v1:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t51.in" title="Al2 molecule,  inversion point shifted from the origin,  ixc=0, kpt=1/4 1/4 1/4,  nsym=4. Large number of bands (20 instead of 3). 8 first SCF steps with simple mixing algorithm,  mixing factor 1/5. Slow convergence. Computation of the hermitian dielectric matrix at the 8th step. The inverse of the dielectric matrix is then used as preconditioning. A factor of 20 is gained on each step. Largest eigenvalue value of the dielectric matrix is 5.712 (a mixing factor of 1/3 would have been enough,  but 1/5 is faster). A second eigenvalue is close : 5.531 .">tests/v1/Input/t51.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t53.in" title="Si2 molecule,  spin-polarized. ixc=0. 7 states for each spin. First,  converge using mixing factor,  then evaluate RPA dielectric matrix,  and use it for convergence.">tests/v1/Input/t53.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t54.in" title="Same as case 53,  but exchange-correlation included. The convergence is not as good as in case 53,  but still much better than simple mixing.">tests/v1/Input/t54.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t55.in" title="Molybdenum slab : 5 layers of Mo + 3 layers of vacuum,  ixc=0 . Central layer is slightly displaced,  to break the symmetry. Metallic occupation numbers. Only 20 bands,  while at least 15 are needed. Use iscf=2,  start with default metallic preconditioner, damped (diemix=0.5d0). A factor of 2 is gained at each iteration. Then evaluate RPA matrix eigenvalues using the extrapolation,  and including the metallic correction. Largest are 3.2541E+01  1.2089E+01  6.1305E+00 . Then,  uses the dielectric matrix preconditioning to converge. No damping is needed. A factor of about 10 is gained at each iteration on average.">tests/v1/Input/t55.in</a></li>
<li>v2:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v2/Input/t05.in" title="Linear chain of Si2 molecules (2 atoms per unit cell), using a separable pseudopotential,  with ixc=3. Computation of the second derivatives of the total energy with respect to a atomic displacement along the chain, with q(0 0 0) wavevector,  as well as to an homogeneous electric field. The computed derivatives include the mixed derivative wrt the two perturbations. (see test.si.elfd of RESPFN)">tests/v2/Input/t05.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v2/Input/t08.in" title="Linear chain of Si2 molecules (2 atoms per unit cell), using a separable pseudopotential,  with ixc=5 and non-linear XC core correction. Computation of the second derivatives of the total energy with respect to a atomic displacement along the chain, with q(0 0 0) wavevector. (see test.si.core0 of RESPFN)">tests/v2/Input/t08.in</a></li>
<li>v6:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t01.in" title="Chain of Silicon diatomic molecules (4 Si2 molecules in the cell) Freeze oscillatory perturbations with different wavelengths and intensities, thanks to the qprtrb and vprtrb input variables. This should be linked with the computation of the dielectric constant, test v2#05,  that uses directly the RF capabilities of ABINIT, for one diatomic molecule. For dataset 1,  one reproduces the results obtained in Tv2#05,  multiplied by 4. The total energy is consistent up to more than 10 digits : -6.6499924738006 Ha for Tv2#05,  -26.599969895203 Ha for the present calculation. For dataset 2,  the perturbation qprtrb 0 0 1 is frozen in,  with vprtrb 100. The total energy is -26.600317638775 Ha. The difference wrt the unperturbed situation is 0.000348743572 Ha. For dataset 3,  a much smaller perturbation (10 times smaller) is taken, giving total energy -26.599973367786 Ha. The difference wrt the unperturbed situation is 0.3472583 microHa. For dataset 4,  an even smaller perturbation (100 times smaller) is taken, giving total energy -26.599969929928 Ha. The difference wrt the unperturbed situation is 0.000034725 microHa. With datasets 3 and 4,  we are in the linear regime. The previous amplitude is better for such studies. Dataset 5 is the same as 3,  with reversed amplitude. Results are similar to dataset 3. I had no sufficient time to analyze these data correctly and make the connection with the results of Tv2#05,  unfortunately. The following (also test 02 below) gives some more data,  and raise questions. There might be some problem with the use of qprtrb and vprtrb. For dataset 2,  the group of the four lowest eigenenergies (each corresponding to a different molecule) is : -0.47198  -0.46381  -0.46091  -0.45266,  whose spread is 0.01932 Ha. One might think that the maximum and minimum of the potential are separated roughly by 0.02 Ha. The value vprtrb 100 corresponds to a cosine wave whose amplitude is 100,  divided by the volume of the cell,  that is 5000 Bohr^3 : 0.02 Ha. The maximum and minimum of the potential should thus be separated by 0.04 Ha. There seems to be a factor of 2 off.">tests/v6/Input/t01.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t02.in" title="Chain of Silicon diatomic molecules (4 Si2 molecules in the cell) Freeze oscillatory perturbations with different wavelengths and intensities, thanks to the qprtrb and vprtrb input variables. Compute the dielectric constant. Similar to test v6#01, but uses a more symmetric geometry,  to examine invariance of the response with respect to shifts of potential,  and also a shorter wavelength. I do not understand why vprtrb 0 10.0 leads to no response. Such a sine wave should cause similar response as for the cosine wave. No time presently to investigate this problem (XG090909)">tests/v6/Input/t02.in</a></li>
</ul>
<p>Gives a rough estimation of the dielectric gap between the highest energy
level computed in the run, and the set of bands not represented. Used to
extrapolate dielectric matrix when <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a> &gt;= 21.<br />
Can be specified in Ha (the default), Ry, eV or Kelvin, since <a class="wikilink" href="../../input_variables/gstate/#diegap">diegap</a> has
the '<a class="wikilink" href="../../ENERGY/">ENERGY</a>' characteristics. (1 Ha=27.2113845 eV)<br />
No meaning for RF calculations yet.</p>
<hr />
<h2 id="dielam"><strong>dielam</strong><a class="headerlink" href="#dielam" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> DIElectric matrix LAMbda<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/SCFAlgorithms">SCFAlgorithms</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.5<br />
<em>Only relevant if:</em> <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a> &gt;= 21<br />
Test list:</p>
<ul>
<li>v1:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t51.in" title="Al2 molecule,  inversion point shifted from the origin,  ixc=0, kpt=1/4 1/4 1/4,  nsym=4. Large number of bands (20 instead of 3). 8 first SCF steps with simple mixing algorithm,  mixing factor 1/5. Slow convergence. Computation of the hermitian dielectric matrix at the 8th step. The inverse of the dielectric matrix is then used as preconditioning. A factor of 20 is gained on each step. Largest eigenvalue value of the dielectric matrix is 5.712 (a mixing factor of 1/3 would have been enough,  but 1/5 is faster). A second eigenvalue is close : 5.531 .">tests/v1/Input/t51.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t53.in" title="Si2 molecule,  spin-polarized. ixc=0. 7 states for each spin. First,  converge using mixing factor,  then evaluate RPA dielectric matrix,  and use it for convergence.">tests/v1/Input/t53.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t54.in" title="Same as case 53,  but exchange-correlation included. The convergence is not as good as in case 53,  but still much better than simple mixing.">tests/v1/Input/t54.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t55.in" title="Molybdenum slab : 5 layers of Mo + 3 layers of vacuum,  ixc=0 . Central layer is slightly displaced,  to break the symmetry. Metallic occupation numbers. Only 20 bands,  while at least 15 are needed. Use iscf=2,  start with default metallic preconditioner, damped (diemix=0.5d0). A factor of 2 is gained at each iteration. Then evaluate RPA matrix eigenvalues using the extrapolation,  and including the metallic correction. Largest are 3.2541E+01  1.2089E+01  6.1305E+00 . Then,  uses the dielectric matrix preconditioning to converge. No damping is needed. A factor of about 10 is gained at each iteration on average.">tests/v1/Input/t55.in</a></li>
<li>v2:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v2/Input/t05.in" title="Linear chain of Si2 molecules (2 atoms per unit cell), using a separable pseudopotential,  with ixc=3. Computation of the second derivatives of the total energy with respect to a atomic displacement along the chain, with q(0 0 0) wavevector,  as well as to an homogeneous electric field. The computed derivatives include the mixed derivative wrt the two perturbations. (see test.si.elfd of RESPFN)">tests/v2/Input/t05.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v2/Input/t08.in" title="Linear chain of Si2 molecules (2 atoms per unit cell), using a separable pseudopotential,  with ixc=5 and non-linear XC core correction. Computation of the second derivatives of the total energy with respect to a atomic displacement along the chain, with q(0 0 0) wavevector. (see test.si.core0 of RESPFN)">tests/v2/Input/t08.in</a></li>
<li>v6:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t01.in" title="Chain of Silicon diatomic molecules (4 Si2 molecules in the cell) Freeze oscillatory perturbations with different wavelengths and intensities, thanks to the qprtrb and vprtrb input variables. This should be linked with the computation of the dielectric constant, test v2#05,  that uses directly the RF capabilities of ABINIT, for one diatomic molecule. For dataset 1,  one reproduces the results obtained in Tv2#05,  multiplied by 4. The total energy is consistent up to more than 10 digits : -6.6499924738006 Ha for Tv2#05,  -26.599969895203 Ha for the present calculation. For dataset 2,  the perturbation qprtrb 0 0 1 is frozen in,  with vprtrb 100. The total energy is -26.600317638775 Ha. The difference wrt the unperturbed situation is 0.000348743572 Ha. For dataset 3,  a much smaller perturbation (10 times smaller) is taken, giving total energy -26.599973367786 Ha. The difference wrt the unperturbed situation is 0.3472583 microHa. For dataset 4,  an even smaller perturbation (100 times smaller) is taken, giving total energy -26.599969929928 Ha. The difference wrt the unperturbed situation is 0.000034725 microHa. With datasets 3 and 4,  we are in the linear regime. The previous amplitude is better for such studies. Dataset 5 is the same as 3,  with reversed amplitude. Results are similar to dataset 3. I had no sufficient time to analyze these data correctly and make the connection with the results of Tv2#05,  unfortunately. The following (also test 02 below) gives some more data,  and raise questions. There might be some problem with the use of qprtrb and vprtrb. For dataset 2,  the group of the four lowest eigenenergies (each corresponding to a different molecule) is : -0.47198  -0.46381  -0.46091  -0.45266,  whose spread is 0.01932 Ha. One might think that the maximum and minimum of the potential are separated roughly by 0.02 Ha. The value vprtrb 100 corresponds to a cosine wave whose amplitude is 100,  divided by the volume of the cell,  that is 5000 Bohr^3 : 0.02 Ha. The maximum and minimum of the potential should thus be separated by 0.04 Ha. There seems to be a factor of 2 off.">tests/v6/Input/t01.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t02.in" title="Chain of Silicon diatomic molecules (4 Si2 molecules in the cell) Freeze oscillatory perturbations with different wavelengths and intensities, thanks to the qprtrb and vprtrb input variables. Compute the dielectric constant. Similar to test v6#01, but uses a more symmetric geometry,  to examine invariance of the response with respect to shifts of potential,  and also a shorter wavelength. I do not understand why vprtrb 0 10.0 leads to no response. Such a sine wave should cause similar response as for the cosine wave. No time presently to investigate this problem (XG090909)">tests/v6/Input/t02.in</a></li>
</ul>
<p>Gives the amount of occupied states with mean energy given by the highest
level computed in the run, included in the extrapolation of the dielectric
matrix.<br />
No meaning for RF calculations yet.</p>
<hr />
<h2 id="dielng"><strong>dielng</strong><a class="headerlink" href="#dielng" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> model DIElectric screening LeNGth<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/SCFAlgorithms">SCFAlgorithms</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1.0774841d0  </p>
<p>Used for screening length (in Bohr) of the model dielectric function, diagonal
in reciprocal space. By default, given in Bohr atomic units (1
Bohr=0.5291772108 Angstrom), although Angstrom can be specified, if preferred,
since <a class="wikilink" href="../../input_variables/gstate/#dielng">dielng</a> has the '<a class="wikilink" href="../../LENGTH/">LENGTH</a>' characteristics.<br />
This model dielectric function is as follows (K being a wavevector) :</p>
<pre><code>         (     1        +     [[dielng]]2* K2   )
diel(K)= ------------------------------------
         ( 1/[[diemac]] + [[dielng]]2 * K2 ) * [[diemix]]
</code></pre>
<p>The inverse of this model dielectric function will be applied to the residual,
to give the preconditioned change of potential. Right at K=0, diel(K) is
imposed to be 1.</p>
<p>If the preconditioning were perfect, the change of potential would lead to an
exceedingly fast solution of the self-consistency problem (two or three
steps). The present model dielectric function is excellent for rather
homogeneous unit cells.<br />
When K-&gt;0 , it tends to the macroscopic dielectric constant, eventually
divided by the mixing factor <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> (or <a class="wikilink" href="../../input_variables/gstate/#diemixmag">diemixmag</a>  for magnetization).<br />
For metals, simply put <a class="wikilink" href="../../input_variables/gstate/#diemac">diemac</a> to a very large value (10^6 is OK)<br />
The screening length <a class="wikilink" href="../../input_variables/gstate/#dielng">dielng</a> governs the length scale to go from the
macroscopic regime to the microscopic regime, where it is known that the
dielectric function should tend to 1. It is on the order of 1 Bohr for metals
with medium density of states at the Fermi level, like Molybdenum, and for
Silicon. For metals with a larger DOS at the Fermi level (like Iron), the
screening will be more effective, so that <a class="wikilink" href="../../input_variables/gstate/#dielng">dielng</a> has to be decreased by a
factor of 2-4.<br />
This works for GS and RF calculations.</p>
<hr />
<h2 id="diemac"><strong>diemac</strong><a class="headerlink" href="#diemac" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> model DIElectric MACroscopic constant<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/SCFAlgorithms">SCFAlgorithms</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1000000.0  </p>
<p>A rough knowledge of the macroscopic dielectric constant <a class="wikilink" href="../../input_variables/gstate/#diemac">diemac</a> of the
system is a useful help to speed-up the SCF procedure: a model dielectric
function, see the keyword <a class="wikilink" href="../../input_variables/gstate/#dielng">dielng</a>, is used for that purpose. It is
especially useful for speeding up the treatment of rather homogeneous unit
cells.</p>
<p>Some hint :<br />
The value of <a class="wikilink" href="../../input_variables/gstate/#diemac">diemac</a> should usually be bigger than 1.0d0, on physical
grounds.<br />
For metals, simply put <a class="wikilink" href="../../input_variables/gstate/#diemac">diemac</a> to a very large value (the default 10  6  is
OK)<br />
For silicon, use 12.0 . A similar value is likely to work well for other
semiconductors<br />
For wider gap insulators, use 2.0 ... 4.0<br />
For molecules in an otherwise empty big box, try 1.5 ... 3.0<br />
Systems that combine a highly polarisable part and some vacuum are rather
badly treated by the model dielectric function. One has to use the
"extrapolar" technique, activated by the input variable <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a>.<br />
In sufficiently homogeneous systems, you might have to experiment a bit to
find the best <a class="wikilink" href="../../input_variables/gstate/#diemac">diemac</a>. If you let <a class="wikilink" href="../../input_variables/gstate/#diemac">diemac</a> to its default value, you
might even never obtain the self-consistent convergence !<br />
For response function calculations, use the same values as for GS. The
improvement in speed can be considerable for small (but non-zero) values of
the wavevector.</p>
<hr />
<h2 id="diemix"><strong>diemix</strong><a class="headerlink" href="#diemix" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> model DIElectric MIXing factor<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/SCFAlgorithms">SCFAlgorithms</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1.0 if <a class="wikilink" href="../../input_variables/internal/#usepaw">usepaw</a>==0 or <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a> !=0,
0.7 if <a class="wikilink" href="../../input_variables/internal/#usepaw">usepaw</a>==1 or <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a>==0,
None otherwise.</p>
<p><em>Only relevant if:</em> <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> &gt;= 0.0 and <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> &lt;=  1.0  </p>
<p>Gives overall factor of the preconditioned residual density/potential to be
transferred in the SCF cycle.<br />
It should be between 0.0 and 1.0 .<br />
If the model dielectric function were perfect, <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> should be 1.0 . By
contrast, if the model dielectric function does nothing (when <a class="wikilink" href="../../input_variables/gstate/#diemac">diemac</a>=1.0d0
or <a class="wikilink" href="../../input_variables/gstate/#dielng">dielng</a> is larger than the size of the cell), <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> can be used to
damp the amplifying factor inherent to the SCF loop.<br />
For molecules, a value on the order 0.5 or 0.33 is rather usual.<br />
When mod(<a class="wikilink" href="../../input_variables/basic/#iscf">iscf</a>,10)=3, 4 ,5 or 7, <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> is only important at the few
first iterations when anharmonic effects are important, since these schemes
compute their own mixing factor for self-consistency.<br />
Also note that a different value of diemix can be used for the magnetization
(see <a class="wikilink" href="../../input_variables/gstate/#diemixmag">diemixmag</a>).</p>
<hr />
<h2 id="diemixmag"><strong>diemixmag</strong><a class="headerlink" href="#diemixmag" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> model DIElectric MIXing factor for the MAGgnetization<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/spinpolarisation">spinpolarisation</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> if 70 &lt; <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a> and <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a> &lt; 80,
<a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> if <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a>==0,
<a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> if <a class="wikilink" href="../../input_variables/basic/#iscf">iscf</a>&lt;10,
-<a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> otherwise.</p>
<p>Test list:</p>
<ul>
<li>gpu:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/gpu/Input/t03.in" title="NiO - LDA+U - fcc structure Test the use of GPU within Projector Augmented-Wave formalism. Test ferromagnetic and non-collinear magnetism. ABINIT v7.0: GPU is not used when nspinor=2">tests/gpu/Input/t03.in</a></li>
<li>v1:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t53.in" title="Si2 molecule,  spin-polarized. ixc=0. 7 states for each spin. First,  converge using mixing factor,  then evaluate RPA dielectric matrix,  and use it for convergence.">tests/v1/Input/t53.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t54.in" title="Same as case 53,  but exchange-correlation included. The convergence is not as good as in case 53,  but still much better than simple mixing.">tests/v1/Input/t54.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t16.in" title="NiO: 2 Ni and 2 O atoms in an fcc supercell. Different combinations of nsppol/nspden/nspinor/pawspnorb are tested in the PAW+U formalism: 1- non-magnetic                     nsppol/nspden/nspinor=1/1/1 2- non-magnetic LDA+U               nsppol/nspden/nspinor=1/1/1 3- ferro-magnetic LDA+U             nsppol/nspden/nspinor=2/2/1 4- antiferro-magnetic LDA+U         nsppol/nspden/nspinor=1/2/1 5- non-collinear magnetism          nsppol/nspden/nspinor=1/4/2 6- non-collinear magnetism LDA+U    nsppol/nspden/nspinor=1/4/2 7- non-collinear magnetism LDA+U+SO nsppol/nspden/nspinor=1/4/2 8- non-magnetic LDA+U+SO            nsppol/nspden/nspinor=1/1/2 Cut-off and k-points are unrealistic.">tests/v5/Input/t16.in</a></li>
</ul>
<p>Gives overall factor of the preconditioned residual magnetization/magnetic
field to be transferred in the SCF cycle (see <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> for further
information).<br />
For the time being, apply only when the SCF mixing is done on the density
(<a class="wikilink" href="../../input_variables/basic/#iscf">iscf</a>&gt;=10).  </p>
<p>A negative value of diemixmag means that magnetization is only preconditionned
by ABS(diemixmag), without the use of any preconditionner.  </p>
<p>When SCF cycle has some difficulties to converge, changing the value of
<a class="wikilink" href="../../input_variables/gstate/#diemixmag">diemixmag</a> can have a positive effect.<br />
In particular <a class="wikilink" href="../../input_variables/gstate/#diemixmag">diemixmag</a>=-4 is a good choice (i.e. diemixmag=4, no other
preconditionner on magnetization).</p>
<hr />
<h2 id="dosdeltae"><strong>dosdeltae</strong><a class="headerlink" href="#dosdeltae" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> DOS DELTA in Energy<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/printing">printing</a>, <a class="wikilink" href="../../topics/ElecDOS">ElecDOS</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.0<br />
Test list:</p>
<ul>
<li>v3:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t46.in" title="2 Silicon atoms,  in a diamond structure. Test the computation of the DOS,  using the linear tetrahedron method.">tests/v3/Input/t46.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t19.in" title="FCC Gadolinium. PAW + U calculation Test the imposition of the density matrix (10 first steps) and related variables. Test of partial DOS is also done (through the diff of DOS_AT0001)">tests/v5/Input/t19.in</a></li>
</ul>
<p>Defines the linear grid resolution (energy increment) to be used for the
computation of the Density-Of-States, when <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a> is non-zero.<br />
If <a class="wikilink" href="../../input_variables/gstate/#dosdeltae">dosdeltae</a> is set to zero (the default value), the actual increment is
0.001 Ha if <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a>=1, and the much smaller value 0.00005 Ha if
<a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a>=2. This different default value arises because the <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a>=1
case, based on a smearing technique, gives a quite smooth DOS, while the DOS
from the tetrahedron method, <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a>=2, is rapidly varying.</p>
<hr />
<h2 id="enunit"><strong>enunit</strong><a class="headerlink" href="#enunit" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> ENergy UNITs<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Output">Output</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0  </p>
<p>Governs the units to be used for output of eigenvalues (and eventual phonon
frequencies)</p>
<ul>
<li>0=&gt;print eigenvalues in hartree; </li>
<li>1=&gt;print eigenvalues in eV; </li>
<li>2=&gt;print eigenvalues in both hartree and eV. </li>
</ul>
<p>If phonon frequencies are to be computed :</p>
<ul>
<li>0=&gt; phonon frequencies in Hartree and cm-1; </li>
<li>1=&gt; phonon frequencies in eV and THz; </li>
<li>2=&gt; phonon frequencies in hartree, eV, cm-1, Thz and Kelvin. </li>
</ul>
<hr />
<h2 id="fband"><strong>fband</strong><a class="headerlink" href="#fband" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Factor for the number of BANDs<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/BandOcc">BandOcc</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.125 if <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>==1,
0.5 if <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>&gt;2,
0.0 if <a class="wikilink" href="../../input_variables/basic/#usewvl">usewvl</a>==1,
0.0 otherwise.</p>
<p>Test list:</p>
<ul>
<li>tutorial:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tfold2bloch_1.in" title="H6 Supercell Generates a 6 atom Hydrogen supercell with the multiplicity of 1:2:3 (x:y:z) Produce WFK file to be analyzed with fold2bloch">tests/tutorial/Input/tfold2bloch_1.in</a></li>
<li>v1:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t03.in" title="Bulk Aluminium,  FCC,  with 2 special points,  occopt=6 and tsmear=0.05. Designed to test the treatment of metals, with the Gaussian-Hermite smearing of Methfessel and Paxton. Also test the use of fband instead of nband.">tests/v1/Input/t03.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t42.in" title="Test the geometry builder : - H2O molecule repeated four times,  with rotations and translations - Si (100) unreconstructed surface : 2*2*2 objects of eight atoms - 16 H atoms at the bottom This test is not realistic (it would take too much time).">tests/v1/Input/t42.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v1/Input/t43.in" title="Test the geometry builder,  and the non-ordering of atoms  : Same thing as test 42,  but with an other order for the input of atoms. Also permutes objects a and b,  to check whether everything is OK.">tests/v1/Input/t43.in</a></li>
</ul>
<p>Governs the number of bands to be used in the code in the case the parameter
<a class="wikilink" href="../../input_variables/basic/#nband">nband</a> is not defined in the input file (which means that <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a> is not
equal to 0 or 2).</p>
<p>In case <a class="wikilink" href="../../input_variables/gstate/#fband">fband</a> is 0.0d0, the code computes from the pseudopotential files
and the geometry data contained in the input file, the number of electrons
present in the system. Then, it computes the minimum number of bands that can
accommodate them, and use that value for <a class="wikilink" href="../../input_variables/basic/#nband">nband</a>.<br />
In case <a class="wikilink" href="../../input_variables/gstate/#fband">fband</a> differs from zero, other bands will be added, just larger
than <a class="wikilink" href="../../input_variables/gstate/#fband">fband</a> times the number of atoms. This parameter is not echoed in the
top of the main output file, but only the parameter <a class="wikilink" href="../../input_variables/basic/#nband">nband</a> that it allowed
to compute. It is also not present in the dtset array (no internal).<br />
The default values are chosen such as to give naturally some conduction bands.
This improves the robustness of the code, since this allows to identify lack
of convergence coming from (near-)degeneracies at the Fermi level. In the
metallic case, the number of bands generated might be too small if the
smearing factor is large. The occupation numbers of the higher bands should be
small enough such as to neglect higher bands. It is difficult to automate
this, so a fixed default value has been chosen.</p>
<hr />
<h2 id="iatsph"><strong>iatsph</strong><a class="headerlink" href="#iatsph" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Index for the ATomic SPHeres of the atom-projected density-of-states<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/printing">printing</a>, <a class="wikilink" href="../../topics/ElecBandStructure">ElecBandStructure</a>, <a class="wikilink" href="../../topics/ElecDOS">ElecDOS</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (<a class="wikilink" href="../../input_variables/gstate/#natsph">natsph</a>)<br />
<em>Default value:</em> [1 .. <a class="wikilink" href="../../natsph]/">natsph]</a><br />
<em>Only relevant if:</em> <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a> == 3 or <a class="wikilink" href="../../input_variables/paw/#pawfatbnd">pawfatbnd</a> in [1,2]<br />
Test list:</p>
<ul>
<li>mpiio:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/mpiio/Input/t26.in" title="C-diamond,  Bulk,  2 atoms,  with PAW. Test the IO routines with paral_kgb in [1,  0] and different combinations of parameters (npfft,  npband,  npkpt). Test the plane wave load balancing procedure (pw_unbal_thresh). Test also the computation of PJDOS.">tests/mpiio/Input/t26.in</a></li>
<li>tutorial:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpaw1_4.in" title="Input for PAW1 tutorial Diamond at experimental volume">tests/tutorial/Input/tpaw1_4.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tspin_3.in" title="Fe fcc structure with two atoms per unit cell for test of antiferromagnetic This is the simplest fcc structure compatible with a X point spiral">tests/tutorial/Input/tspin_3.in</a></li>
<li>v4:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v4/Input/t35.in" title="One He atom in a big simple cubic box Compute the DOS using the tetrahedron method. Also compute the partial DOS. There is a quite surprising feature of this very simple DOS, that might seem to be due to a bug,  but is NOT one. Indeed,  the obtained DOS is not continuous (vizualize the result of DATASET 2):  at two energies,  there is a small,  but sizeable jump. This feature is associated with a rather sparse sampling of the Brillouin zone. Indeed,  some of the tetrahedra have three corners with perfectly identical energies. Such a set of corners belong to two different tetrahedra. If there is not an equal slope of energy when moving away from each sides of the triangles,  in the different tetrahedra, the DOS is discontinuous at the energy of the three shared corners. (explanation found by M. Verstraete)">tests/v4/Input/t35.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v4/Input/t38.in" title="Test the computation of the partial DOS,  using the linear tetrahedron method. 2 Silicon atoms,  in a diamond structure.">tests/v4/Input/t38.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t19.in" title="FCC Gadolinium. PAW + U calculation Test the imposition of the density matrix (10 first steps) and related variables. Test of partial DOS is also done (through the diff of DOS_AT0001)">tests/v5/Input/t19.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t20.in" title="NiO antiferromagnetic. Test of prtfatbnd==2 2 Ni and 2 O atoms in an fcc supercell. The cut-offs are unrealistic. The aim of this test is to verify: * Computation of band structure in PAW+U * Calculation of partial DOS (diffs of partial DOS is not done) * Calculation of Fatbands (diff of a fatband file is done)">tests/v5/Input/t20.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t40.in" title="Density from test 38 is read;  then a non self-consistent calculation is done and the m-decomposed LDOS on the first atom is printed out.">tests/v5/Input/t40.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t04.in" title="Test natsph_extra,  ratsph_extra,  and xredsph_extra for STS calculation. Al (111) surface slab with very low ecut and ngkpt in the plane.">tests/v7/Input/t04.in</a></li>
</ul>
<p><a class="wikilink" href="../../input_variables/gstate/#iatsph">iatsph</a> gives the number of the <a class="wikilink" href="../../input_variables/gstate/#natsph">natsph</a> atoms around which the sphere
for atom-projected density-of-states will be build, in the <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a>=3 case.
The radius of these spheres is given by <a class="wikilink" href="../../input_variables/gstate/#ratsph">ratsph</a>.<br />
If <a class="wikilink" href="../../input_variables/paw/#pawfatbnd">pawfatbnd</a>=1 or 2, it gives the number of the <a class="wikilink" href="../../input_variables/gstate/#natsph">natsph</a> atoms around
which atom-projected band structure will be built.</p>
<hr />
<h2 id="icoulomb"><strong>icoulomb</strong><a class="headerlink" href="#icoulomb" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Index for the Coulomb TReaTMenT<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Coulomb">Coulomb</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0  </p>
<p>Defines the type of computation used for Hartree potential, local part of
pseudo-potential and ion-ion interaction:</p>
<ul>
<li><a class="wikilink" href="../../input_variables/gstate/#icoulomb">icoulomb</a>=0 : usual reciprocal space computation, using 1 / g^2 for the Hartree potential and using Ewald correction. </li>
<li><a class="wikilink" href="../../input_variables/gstate/#icoulomb">icoulomb</a>=1 : free boundary conditions are used when the Hartree potential is computed, real space expressions of pseudo-potentials are involved (restricted to GTH pseudo-potentials) and simple coulomb interaction gives the ion-ion energy. </li>
</ul>
<hr />
<h2 id="iprcel"><strong>iprcel</strong><a class="headerlink" href="#iprcel" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Integer for PReConditioning of ELectron response<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/SCFAlgorithms">SCFAlgorithms</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0  </p>
<p>Used when <a class="wikilink" href="../../input_variables/basic/#iscf">iscf</a>&gt;0, to define the SCF preconditioning scheme. Potential-
based preconditioning schemes for the SCF loop (electronic part) are still a
subject of active research. The present parameter (electronic part) describes
the way the change of potential is derived from the residual.<br />
The possible values of <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a> correspond to :</p>
<ul>
<li>0 =&gt; model dielectric function described by <a class="wikilink" href="../../input_variables/gstate/#diemac">diemac</a>, <a class="wikilink" href="../../input_variables/gstate/#dielng">dielng</a> and <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a>. </li>
<li>larger or equal to 21 =&gt; will compute the dielectric matrix according to <a class="wikilink" href="../../input_variables/gstate/#diecut">diecut</a>, <a class="wikilink" href="../../input_variables/gstate/#dielam">dielam</a>, <a class="wikilink" href="../../input_variables/gstate/#diegap">diegap</a>. This methodology is described in P.-M. Anglade, X. Gonze, Phys. Rev. B 78, 045126 (2008). </li>
<li>Between 21 and 29 =&gt; for the first few steps uses the same as option 0 then compute RPA dielectric function, and use it as such. </li>
<li>Between 31 and 39 =&gt; for the first few steps uses the same as option 0 then compute RPA dielectric function, and use it, with the mixing factor <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a>. </li>
<li>Between 41 and 49 =&gt; compute the RPA dielectric matrix at the first step, and recompute it at a later step, and take into account the mixing factor <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a>. </li>
<li>Between 51 and 59 =&gt; same as between 41 and 49, but compute the RPA dielectric matrix by another mean </li>
<li>Between 61 and 69 =&gt; same as between 41 and 49, but compute the electronic dielectric matrix instead of the RPA one. </li>
<li>Between 71 and 78 =&gt; STILL UNDER DEVELOPMENT -- NOT USABLE ; Use the modified Kerker preconditioner with a real-space formulation (basic formulation is shown at <a class="wikilink" href="../../input_variables/gstate/#dielng">dielng</a>). The dielectric matrix is approximated thanks to <a class="wikilink" href="../../input_variables/gstate/#diemac">diemac</a> and <a class="wikilink" href="../../input_variables/gstate/#dielng">dielng</a>. Note that <a class="wikilink" href="../../input_variables/gstate/#diemix">diemix</a> is also used. </li>
<li>79 =&gt; STILL UNDER DEVELOPMENT -- NOT USABLE ; same as previous but with an alternate algorithm. </li>
<li>141 to 169 =&gt; same as Between 41 and 69 (but, the dielectric matrix is also recomputed every iprcel modulo 10 step). </li>
</ul>
<p>The computation of the dielectric matrix (for 0 [100]&lt; <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a> &lt; 70
[100]) is based on the <strong> extrapolar </strong> approximation. This approximation can
be tuned with <a class="wikilink" href="../../input_variables/gstate/#diecut">diecut</a>, <a class="wikilink" href="../../input_variables/gstate/#dielam">dielam</a>, and <a class="wikilink" href="../../input_variables/gstate/#diegap">diegap</a>. Yet its accuracy mainly
depends on the number of conduction bands included in the system. Having 2 to
10 empty bands in the calculation is usually enough (use <a class="wikilink" href="../../input_variables/basic/#nband">nband</a>).  </p>
<p>NOTES:</p>
<ul>
<li>The step at which the dielectric matrix is computed or recomputed is determined by modulo(<a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a>,10). The recomputation happens just once in the calculation for <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a> &lt; 100. </li>
<li>For non-homogeneous relatively large cells <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a>=45 will likely give a large improvement over <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a>=0. </li>
<li>In case of PAW and <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a>&gt;0, see <a class="wikilink" href="../../input_variables/paw/#pawsushat">pawsushat</a> input variable. By default, an approximation (which can be suppressed) is done for the computation of susceptibility matrix. </li>
<li>For extremely large inhomogeneous cells where computation of the full dielectric matrix takes too many weeks, 70 &lt; <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a> &lt; 80 is advised. </li>
<li>For <a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=2 or <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=2 with metallic <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>, only <strong> mod(iprcel,100) </strong> &lt;50 is allowed. </li>
<li>No meaning for RF calculations yet. </li>
<li>The exchange term in the full dielectric matrix diverges for vanishing densities. Therefore the values of <a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a> beyond 60 must not be used for cells containing vacuum, unless ones computes this matrix for every step (<a class="wikilink" href="../../input_variables/gstate/#iprcel">iprcel</a>=161). </li>
</ul>
<hr />
<h2 id="iqpt"><strong>iqpt</strong><a class="headerlink" href="#iqpt" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Index for QPoinT generation<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/q-points">q-points</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0<br />
Test list:</p>
<ul>
<li>paral:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/paral/Input/t60.in" title="Diamond. Diamond dynamical temperature-dependent of the electronic structure. Three q-points are computed. Test of the parallelization. Must be compared with v7/Refs/t55.out">tests/paral/Input/t60.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/paral/Input/t60.in" title="Diamond. Diamond dynamical temperature-dependent of the electronic structure. Three q-points are computed. Test of the parallelization. Must be compared with v7/Refs/t55.out">tests/paral/Input/t60.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/paral/Input/t60.in" title="Diamond. Diamond dynamical temperature-dependent of the electronic structure. Three q-points are computed. Test of the parallelization. Must be compared with v7/Refs/t55.out">tests/paral/Input/t60.in</a></li>
<li>tutorespfn:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorespfn/Input/tdepes_3.in" title="Temperature dependence calculation of diamond.">tests/tutorespfn/Input/tdepes_3.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorespfn/Input/tdepes_4.in" title="Temperature dependence calculation of diamond.">tests/tutorespfn/Input/tdepes_4.in</a></li>
<li>v6:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t35.in" title="Generate first-order responses for FCC Aluminum. Very low cut-off,  to keep CPU the lowest possible Aim at a regular sampling of phonon wavevectors,  needed to interpolate the dynamical matrix over the whole Brillouin Zone. Use the definition through qptrlatt. Otherwise,  similar to Tv2#26 and Tv6#78.">tests/v6/Input/t35.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t78.in" title="Generate first-order responses for FCC Aluminum. Very low cut-off,  to keep CPU the lowest possible Aim at a regular sampling of phonon wavevectors,  needed to interpolate the dynamical matrix over the whole Brillouin Zone. Use the definition through ngqpt and nshiftq. Otherwise,  similar to Tv2#26">tests/v6/Input/t78.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t50.in" title="Diamond. Test temperature-dependent of the electronic structure,  with reduction of the number of q points to be computed,  thanks to thmflag=7 . The temperature-dependent shifts must be averaged over degenerate states. This temperature-dependent calculation make use of a k-point interpolation to speed up the convergence study with respect to the q-points integration. Two q-points are computed.">tests/v7/Input/t50.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t51.in" title="This tests make use of the irdwfkfine variable instead of the getwfkfine variable used in the previous test. The third q-point is computed here.">tests/v7/Input/t51.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t55.in" title="Diamond. Diamond dynamical temperature-dependent of the electronic structure. Three q-points are computed.">tests/v7/Input/t55.in</a></li>
</ul>
<p>Only used if <a class="wikilink" href="../../input_variables/gstate/#nqpt">nqpt</a>=1, and <a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a>=1 to 4.</p>
<p>Defines the index of the Q point to be selected in the list of q points
generated by <a class="wikilink" href="../../input_variables/gstate/#ngqpt">ngqpt</a>, <a class="wikilink" href="../../input_variables/gstate/#qptrlatt">qptrlatt</a>, <a class="wikilink" href="../../input_variables/gstate/#nshiftq">nshiftq</a>, and <a class="wikilink" href="../../input_variables/gstate/#shiftq">shiftq</a>.</p>
<p>If <a class="wikilink" href="../../input_variables/gstate/#iqpt">iqpt</a>=0, then the q point is Gamma (0 0 0).</p>
<p>The usual working mode is to define a series of values for <a class="wikilink" href="../../input_variables/gstate/#iqpt">iqpt</a>, starting
with <a class="wikilink" href="../../input_variables/gstate/#iqpt">iqpt</a>=0 or 1 (so through the definition of <strong> iqpt: </strong> ), and
increasing it by one for each dataset (thanks to <strong> iqpt+ </strong> ).</p>
<hr />
<h2 id="ixcpositron"><strong>ixcpositron</strong><a class="headerlink" href="#ixcpositron" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Integer for the eXchange-Correlation applied to the electron-POSITRON interaction<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/positron">positron</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1<br />
<em>Comment:</em> (Teter parameterization). However, if all the pseudopotentials have the same value of pspxc, the initial value of ixc will be that common value<br />
Test list:</p>
<ul>
<li>tutorial:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_1.in" title="First step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_1.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_2.in" title="Second step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_2.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_3.in" title="Third step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_3.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_4.in" title="Fourth step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_4.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_5.in" title="Fifth step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_5.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_6.in" title="Sixth step (part 1) of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_6.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_7.in" title="Sixth step (part 2) of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_7.in</a></li>
<li>v4:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v4/Input/t96.in" title="Al FCC,  in conventional cell (4 atoms/cell). Positron calculation : lifetime and decay rate.">tests/v4/Input/t96.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t07.in" title="Test of the computation of the positron lifetime (using the two-component DFT) within PAW. A cubic box with 4 Al atoms at experimental volume. Low cut-offs,  few k-points. Datasets 2 to 3 use ixcpositron=2 i.e. LDA electron-positron correlation provided by Puska, Seitsonen,  and Nieminen (PRB 52,  10947). Datasets 4 to 5 use ixcpositron=11 i.e. LDA zero positron density limit parametrized by Arponen and Pajanne and fitted by Sterne and Kaiser (PRB 43,  13892). Dataset 1 performs a simple electronic GS calculation and store the density. Dataset 2 performs a positronic GS calculation in presence of the electronic density computed by dataset 1 (positron=1). Dataset 3 performs an electronic GS calculation in presence of the positronic density computed by dataset 2 (positron=2). Dataset 4 performs an automatic electronic/positronic GS calculation without storage of the wave-functions (positron=-1). Dataset 5 performs an automatic electronic/positronic GS calculation with storage of the wave-functions (positron=-10). Each dataset computes the positron lifetime and annihilation rate after the SCF iterations.">tests/v5/Input/t07.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t35.in" title="Test of the computation of the electron-positron Doppler broadening (using the two-component DFT) within PAW. A cubic box with 4 Al atoms at experimental volume. Low cut-offs,  few k-points. Computes the positron lifetime and well as the electron-positron pairs momentum distributions,  after the SCF iterations.">tests/v7/Input/t35.in</a></li>
</ul>
<p>Relevant only when <a class="wikilink" href="../../input_variables/gstate/#positron">positron</a>/=0.<br />
Define the type of electron-positron correlation that is used in case of a
electron-positron two-component DFT calculation.<br />
Define also the analytical formula of the enhancement factor used to compute
the electron-positron annhilation rate:  </p>
<p>Electron-positron correlation functional:  </p>
<p><strong> ixcpositron=1 </strong> : LDA zero positron density limit parametrized by Arponen &amp; Pajanne and provided by Boronski &amp; Nieminen [1,2] <br />
<strong> ixcpositron=11 </strong> : LDA zero positron density limit parametrized by Arponen &amp; Pajanne and fitted by Sterne &amp; Kaiser [1,3] <br />
<strong> ixcpositron=2 </strong> : LDA electron-positron correlation provided by Puska, Seitsonen, and Nieminen [1,4] <br />
<strong> ixcpositron=3 </strong> : GGA zero positron density limit parametrized by Arponen &amp; Pajanne and provided by Boronski &amp; Nieminen [1,2,5] <br />
<strong> ixcpositron=31 </strong> : GGA zero positron density limit parametrized by Arponen &amp; Pajanne and fitted by Sterne &amp; Kaiser [1,3,5] 
Annihilation rate enhancement factor:  </p>
<p><strong> ixcpositron=1 </strong> : Boronski and Nieminen full modelisation and RPA limit [1] <br />
<strong> ixcpositron=11 </strong> : Sterne and Kaiser [2] <br />
<strong> ixcpositron=2 </strong> : Puska, Seitsonen and Nieminen [3] <br />
<strong> ixcpositron=3 </strong> : Boronski and Nieminen full modelisation and RPA limit [1], with GGA corrections <br />
<strong> ixcpositron=31 </strong> : Sterne and Kaiser [2], with GGA corrections   </p>
<p>References:  <strong> [1] </strong> J. Arponen and E. Pajanne, Ann. Phys. (N.Y.) 121, 343
(1979).<br />
<strong> [2] </strong> Boronski and R.M. Nieminen, Phys. Rev. B 34, 3820 (1986). <br />
<strong> [3] </strong> P.A. Sterne and J.H. Kaiser, Phys. Rev. B 43, 13892 (1991). <br />
<strong> [4] </strong> M.J. Puska, A.P. Seitsonen and R.M. Nieminen, Phys. Rev. B 52, 10947 (1994). <br />
<strong> [5] </strong> B. Barbiellini, M.J. Puska, T. Torsti and R.M.Nieminen, Phys. Rev. B 51, 7341 (1994)   </p>
<hr />
<h2 id="jellslab"><strong>jellslab</strong><a class="headerlink" href="#jellslab" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> include a JELLium SLAB in the cell<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Artificial">Artificial</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0<br />
Test list:</p>
<ul>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t56.in" title="Bulk jellium (the slab fills up the entire cell): computation of the total energy. Tested 3 Wigner-Seitz radii: 1.5,  2 (~aluminum),  4. For each Wigner-Seitz radius the energy per particle agrees with that analytically calculated using the Teter-Pade functional form. The number of k points has been much reduced,  for the purpose of the automatic testing.">tests/v5/Input/t56.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t57.in" title="Jellium slab (50 jellium/ 50 vacuum) with Wigner-Seitz radius=4. Computation of the total energy The number of k points has been much reduced">tests/v5/Input/t57.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t58.in" title="Jellium thin slab with Wigner-Seitz radius=2.56 (~copper) + 1 Na adatom. Computation of the total energy and force on the Na atom. Its position with respect to the slab already is the equilibrium position so the calculation should use only one optimization step.">tests/v5/Input/t58.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t59.in" title="Jellium thin slab with Wigner-Seitz radius=2.56 (~copper) + 1 Na adatom. Computation of the total energy at the Na equilibrium distance from the jellium edge and two other ones,  slightly farther and slightly closer. The total energies should indicate as more stable the equilibrium distance. The number of k points has been much reduced">tests/v5/Input/t59.in</a></li>
</ul>
<p>If set to 1, a slab of uniform positive background charge density, that is, a
jellium slab, is included in the calculation cell. A portion of the unit cell
is filled with such positive charge density distribution which is equal to a
bulk-mean value n  bulk  between two edges and zero in the vacuum region if
present.<br />
For the sake of convenience the unit cell is supposed to have the third
crystal primitive lattice vector orthogonal to the other ones so that the
portion of the cell filled by the jellium slab can be defined through its
edges along z.<br />
The bulk-mean positive charge density is fixed by the input variable
<a class="wikilink" href="../../input_variables/gstate/#slabwsrad">slabwsrad</a>, while the position of the slab edges along z is defined through
the input variables <a class="wikilink" href="../../input_variables/gstate/#slabzbeg">slabzbeg</a> and <a class="wikilink" href="../../input_variables/gstate/#slabzend">slabzend</a>.</p>
<hr />
<h2 id="kptbounds"><strong>kptbounds</strong><a class="headerlink" href="#kptbounds" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> K PoinT BOUNDarieS<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/k-points">k-points</a>, <a class="wikilink" href="../../topics/ElecBandStructure">ElecBandStructure</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> (3,abs(<a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a>)+1))<br />
<em>Default value:</em> None  </p>
<p>It is used to generate the circuit to be followed by the band structure, when
<a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> is negative (it is not read if <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> is zero or positive).</p>
<p>There are abs(<a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a>) segments to be defined, each of which starting from
the end point of the preceeding one. Thus, the number of points to be input is
abs(<a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a>)+1. They form a circuit starting at
<a class="wikilink" href="../../input_variables/gstate/#kptbounds">kptbounds</a>(1:3,1)/<a class="wikilink" href="../../input_variables/basic/#kptnrm">kptnrm</a> and ending at
<a class="wikilink" href="../../input_variables/gstate/#kptbounds">kptbounds</a>(1:3,abs(<a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a>)+1)/<a class="wikilink" href="../../input_variables/basic/#kptnrm">kptnrm</a>. The number of divisions of
each segment can be defined either using the array <a class="wikilink" href="../../input_variables/gstate/#ndivk">ndivk</a> or the variable
<a class="wikilink" href="../../input_variables/gstate/#ndivsm">ndivsm</a> that just defines the number of divisions for the smallest segment</p>
<p>As for <a class="wikilink" href="../../input_variables/basic/#kpt">kpt</a>, <a class="wikilink" href="../../input_variables/gstate/#kptbounds">kptbounds</a> is specified using the primitive vectors in
reciprocal space. If your Bravais lattice is simple, then it should be quite
easy to find the coordinates of the end points. On the other hand, for
centered, body-centered, face-centered, hexagonal, and rhombohedral Bravais
lattice, the conversion might be more difficult. See the description of
<a class="wikilink" href="../../input_variables/basic/#kpt">kpt</a> for an explanation of how to convert data from the "conventional"
cartesian coordinates to the primitive vectors in the reciprocal space. In
order to help a bit, we list below a series of typical values, for the FCC,
BCC, hexagonal and rhombohedral Bravais lattices. Note : all the data below
are given in dimensionless units ; they have to be rescaled by the actual
lengths defined by the <a class="wikilink" href="../../input_variables/basic/#acell">acell</a> values. However, <a class="wikilink" href="../../input_variables/gstate/#kptbounds">kptbounds</a> values can be
used as such, if the values of <a class="wikilink" href="../../input_variables/basic/#rprim">rprim</a> given below are adopted.</p>
<p>A. <strong> FCC lattice </strong></p>
<p>Suppose the primitive vectors in real space are given by  </p>
<pre><code>  rprim   0 1 1    1 0 1    1 1 0
</code></pre>
<p>or</p>
<pre><code>  rprim   0 1/2 1/2    1/2 0 1/2    1/2 1/2 0
</code></pre>
<p>(these two possibilities only differ by a scaling factor, irrelevant for the
definition of the k points in the primitive vectors in reciprocal space).
Then, the reciprocal primitive vectors (in conventional cartesian coordinates)
are</p>
<pre><code>  (-1/2 1/2 1/2), (1/2 -1/2 1/2), (1/2 1/2 -1/2)
</code></pre>
<p>or</p>
<pre><code>  (-1 1 1), (1 -1 1), (1 1 -1)
</code></pre>
<p>and, in both cases, the coordinates of several special points with respect to
primitive vectors in reciprocal space are</p>
<pre><code>  X (0   1/2 1/2)   (conventional cartesian coordinate 1/2 0 0)
  X'(1/2 1/2 1  )   (conventional cartesian coordinate 1/2 1/2 0)  (an other instance of X, in another Brillouin zone)
  L (1/2 1/2 1/2)   (conventional cartesian coordinate  1/4 1/4 1/4)
  L'(1/2 0   0  )   (conventional cartesian coordinate -1/4 1/4 1/4) (an other instance of L, on another face of the BZ)
  W (1/4 1/2 3/4)   (conventional cartesian coordinate 1/2 1/4 0)
  U (1/4 5/8 5/8)   (conventional cartesian coordinate 1/2 1/8 1/8)
  K (3/8 3/8 3/4)   (conventional cartesian coordinate 3/8 3/8 0)
</code></pre>
<p>Note that K is actually equivalent to U, by spatial and translational
symmetry. So, if you want to specify a typical circuit, the following might do
the work : L-Gamma-X-W-K,U-L-W-X-K,U-Gamma with  </p>
<pre><code>  kptbounds  1/2 0 0  0 0 0  0 1/2 1/2  1/4 1/2 3/4  3/8 3/8 3/4  1/2 1/2 1/2  1/4 1/2 3/4  1/2 1/2 1  3/8 3/8 3/4  0 0 0
</code></pre>
<p>The lengths of segments (this information is useful to draw the band
structure, with the correct relative scale between special points) can be
found using the conventional cartesian coordinates :
l(L-Gamma)=sqrt(3)/4=0.433... ; l(Gamma-X)=1/2=0.5 ; l(X-W)=1/4=0.25 ;
l(W-K)=sqrt(2)/8=0.177... ; l(K-L)=sqrt(6)/8=0.306... ;
l(L-W)=sqrt(2)/4=0.354... ; l(W-X)=1/4=0.25 ; l(X-K)=sqrt(2)/8=0.177... ;
l(K-Gamma)=sqrt(2).3/8=0.530...</p>
<p>B. <strong> BCC lattice </strong></p>
<p>Suppose the primitive vectors in real space are given by  </p>
<pre><code>  rprim  -1 1 1    1 -1 1    1 1 -1
</code></pre>
<p>(as for the FCC lattice, there is a scale invariance). Then, the reciprocal
primitive vectors (in conventional cartesian coordinates) are (0 1/2 1/2),
(1/2 0 1/2), and (1/2 1/2 0) and the coordinates of several special points
with respect to primitive vectors in reciprocal space are</p>
<pre><code>  H (-1/2 1/2 1/2)   (conventional cartesian coordinate 1/2 0 0)
  N ( 0   0   1/2)   (conventional cartesian coordinate 1/4 1/4 0)
  P ( 1/4 1/4 1/4)   (conventional cartesian coordinate 1/4 1/4 1/4)
</code></pre>
<p>So, if you want to specify a typical circuit, the following might do the work
: Gamma-H-N-Gamma-P-N-P-H  </p>
<pre><code>  kptbounds  0 0 0  -1/2 1/2 1/2  0 0 1/2  0 0 0   1/4 1/4 1/4  0 0 1/2  1/4 1/4 1/4  -1/2 1/2 1/2
</code></pre>
<p>The lengths of segments (this information is useful to draw the band
structure, with the correct relative scale between special points) can be
found using the conventional cartesian coordinates : l(Gamma-H)=1/2=0.5 ;
l(H-N)=sqrt(2)/4=0.354... ; l(N-Gamma)=sqrt(2)/4=0.354... ;
l(Gamma-P)=sqrt(3)/4=0.433... ; l(P-N)=1/4=0.25 ; l(N-P)=1/4=0.25 ;
l(P-H)=sqrt(3)/4=0.433...</p>
<p>C. <strong> Hexagonal lattices </strong></p>
<p>Suppose the primitive vectors in real space are given by  </p>
<pre><code>  rprim  1 0 0    -1/2 sqrt(0.75) 0    0 0 1
</code></pre>
<p>The coordinates of several special points with respect to primitive vectors in
reciprocal space are</p>
<pre><code>  M (1/2 0 0) or (0 1/2 0) or (-1/2 1/2 0)
  L (1/2 0 1/2) or (0 1/2 1/2) or (-1/2 1/2 1/2)
  K (1/3 1/3 0) or (2/3 -1/3 0) or (-1/3 2/3 0)
  H (1/3 1/3 1/2) or (2/3 -1/3 1/2) or (-1/3 2/3 1/2)
  A (0 0 1/2)
</code></pre>
<p>So, if you want to specify a typical circuit, the following might do the work
: K-Gamma-M-K-H-A-L-H-L-M-Gamma-A  </p>
<pre><code>  kptbounds  1/3 1/3 0  0 0 0  1/2 0 0  1/3 1/3 0  1/3 1/3 1/2  0 0 1/2  1/2 0 1/2  1/3 1/3 1/2  1/2 0 1/2  1/2 0 0  0 0 0  0 0 1/2
</code></pre>
<p>In order to find the lengths of segments (this information is useful to draw
the band structure, with the correct relative scale between special points)
one needs to know the a and c lattice parameters. Also, in what follows, we
omit the 2<em>pi factor sometimes present in the definition of the reciprocal
space vectors. The reciprocal vectors are (1/a 1/(sqrt(3)</em>a) 0) , (0
2/(sqrt(3)<em>a) 0), (0 0 1/c). The lengths of the above-mentioned segments can
be computed as : l(K-Gamma)=2/(3</em>a)=0.666.../a ;
l(Gamma-M)=1/(sqrt(3)<em>a)=0.577.../a ; l(M-K)=1/(3</em>a)=0.333.../a ;
l(K-H)=1/(2<em>c)=0.5.../c ; l(H-A)=2/(3</em>a)=0.666.../a ;
l(A-L)=1/(sqrt(3)<em>a)=0.577.../a ; l(L-H)=1/(3</em>a)=0.333.../a ;
l(H-L)=1/(3<em>a)=0.333.../a ; l(L-M)=1/(2</em>c)=0.5.../c ;
l(M-Gamma)=-1/(sqrt(3)<em>a)=0.577.../a ; l(Gamma-A)=1/(2</em>c)=0.5.../c</p>
<p>D. <strong> Rhombohedral lattices </strong></p>
<p>Rhombohedral lattices are characterised by two parameters, the length of the
primitive vectors, that we will denote a0, and the angle they form, alpha.
These can be directly input of ABINIT, as <a class="wikilink" href="../../input_variables/basic/#acell">acell</a> and <a class="wikilink" href="../../input_variables/basic/#angdeg">angdeg</a></p>
<p>This will generate the primitive vectors in real space , with</p>
<pre><code>  [[acell]] a0 a0 a0    and      [[rprim]]  a 0 c    -a/2 a*sqrt(0.75) c    -a/2 -a*sqrt(0.75) c
</code></pre>
<p>with a^2+c^2=1, a^2=(1-cos(alpha))<em>2/3, c^2=(1+2</em>cos(alpha))<em>1/3,
(a/c)^2=2</em>(1-cos(alpha))/(1+2*cos(alpha)) and also
cos(alpha)=(1-(a/c)^2/2)/(1+(a/c)^2). Alternatively, these values of rprim
might directly be the input of ABINIT (then, the balance of the scaling factor
might be adjusted between <a class="wikilink" href="../../input_variables/basic/#acell">acell</a> and <a class="wikilink" href="../../input_variables/basic/#rprim">rprim</a>).</p>
<p>Unlike for the simple cubic, FCC, BCC, hexagonal (and some other) Bravais
lattice, the topology of the Brillouin zone will depend on the alpha (or a/c)
value. We give below information concerning the case when cos(alpha) is
positive, that is, (a/c)^2 lower than 2.</p>
<p>The coordinates of several special points with respect to primitive vectors in
reciprocal space will not depend on the a/c ratio, but some others will depend
on it. So, some care has to be exercised. Notations for the Brillouin Zone
special points are the same as in Phys. Rev. B 41, 11827 (1990).</p>
<pre><code>  L (1/2 0 0) or (0 1/2 0) or (0 0 1/2) (or with negative signs)
  T (1/2 1/2 1/2)
  X (1/2 1/2 0) or (1/2 0 1/2) or (0 1/2 1/2) (or with separate negative signs)
  W (5/6 - (a/c)^2/6 , 1/2 , 1/6 + (a/c)^2/6 ) = (1 0 -1)*(1-(a/c)^2/2)/3 + (1 1 1)/2
  U ( (1+(a/c)^2)/6 , (8-(a/c)^2)/12 , (8-(a/c)^2)/12 ) = (-1 1/2 1/2)*(1-(a/c)^2/2)/3 + (1 1 1)/2
  K (1 0 -1)*(1+(a/c)^2/4)/3
</code></pre>
<p>So, if you want to specify a typical circuit, the following might do the work
(the representative points on lines of symmetry are indicated - there are
sometimes more than one way to go from one point to another) : X-V-K-Sigma-
Gamma-Lambda-T-Q-W-Y-L-sigma-Gamma-sigma-X . The suggestion is to sample this
path with the following coordinates for the special points X, Gamma, T, L,
Gamma, X :  </p>
<pre><code>  kptbounds  1/2 0 -1/2   0 0 0    1/2 1/2 1/2  1 1/2 0   1 0 0  1 1/2 1/2
</code></pre>
<p>In order to find the lengths of segments (this information is useful to draw
the band structure, with the correct relative scale between special points)
one needs to know the a and c lattice parameters. Also, in what follows, we
omit the 2<em>pi factor sometimes present in the definition of the reciprocal
space vectors. The reciprocal vectors are (2/(3</em>a) 0 1/(3<em>c)) , -(1/(3</em>a)
1/(sqrt(3)<em>a) 1/(3</em>c), -(1/(3<em>a) -1/(sqrt(3)</em>a) 1/(3<em>c) ). The lengths of the
above-mentioned segments can be computed as :
l(X-Gamma)=2/(sqrt(3)</em>a)=1.155.../a , with
l(K-Gamma)=(1+(a/c)^2/4)<em>4/(3</em>sqrt(3)<em>a); l(Gamma-T)=1/(2</em>c) ;
l(T-L)=2/(sqrt(3)<em>a)=1.155.../a , with l(T-W)=(1-(a/c)^2/2)</em>4/(3<em>sqrt(3)</em>a);
l(L-Gamma)=sqrt(4/(a^2)+1/(c^2))/3 l(Gamma-X)=sqrt(1/(a^2)+1/(c^2))*2/3</p>
<hr />
<h2 id="kptrlatt"><strong>kptrlatt</strong><a class="headerlink" href="#kptrlatt" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> K - PoinTs grid : Real space LATTice<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/k-points">k-points</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (3,3)<br />
<em>Default value:</em> <em>0<br />
</em>The use of this variable forbids the use of:* specified(<a class="wikilink" href="../../input_variables/basic/#ngkpt">ngkpt</a>)  </p>
<p>This input variable is used only when <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> is positive. It partially
defines the k point grid. The other piece of information is contained in
<a class="wikilink" href="../../input_variables/basic/#shiftk">shiftk</a>. <a class="wikilink" href="../../input_variables/gstate/#kptrlatt">kptrlatt</a> cannot be used together with <a class="wikilink" href="../../input_variables/basic/#ngkpt">ngkpt</a>.</p>
<p>The values kptrlatt(1:3,1), kptrlatt(1:3,2), kptrlatt(1:3,3) are the
coordinates of three vectors in real space, expressed in the <a class="wikilink" href="../../input_variables/basic/#rprimd">rprimd</a>
coordinate system (reduced coordinates). They defines a super-lattice in real
space. The k point lattice is the reciprocal of this super-lattice, possibly
shifted (see <a class="wikilink" href="../../input_variables/basic/#shiftk">shiftk</a>).</p>
<p>If neither <a class="wikilink" href="../../input_variables/basic/#ngkpt">ngkpt</a> nor <a class="wikilink" href="../../input_variables/gstate/#kptrlatt">kptrlatt</a> are defined, ABINIT will automatically
generate a set of k point grids, and select the best combination of
<a class="wikilink" href="../../input_variables/gstate/#kptrlatt">kptrlatt</a> and <a class="wikilink" href="../../input_variables/basic/#shiftk">shiftk</a> that allows to reach a sufficient value of
<a class="wikilink" href="../../input_variables/gstate/#kptrlen">kptrlen</a>. See this latter variable for a complete description of this
procedure.</p>
<hr />
<h2 id="kptrlen"><strong>kptrlen</strong><a class="headerlink" href="#kptrlen" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> K - PoinTs grid : Real space LENgth<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/k-points">k-points</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 30.0  </p>
<p>This input variable is used only when <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> is positive and non-zero.</p>
<p>Preliminary explanation :<br />
The k point lattice defined by <a class="wikilink" href="../../input_variables/basic/#ngkpt">ngkpt</a> or <a class="wikilink" href="../../input_variables/gstate/#kptrlatt">kptrlatt</a> is used to perform
integrations of periodic quantities in the Brillouin Zone, like the density or
the kinetic energy. One can relate the error made by replacing the continuous
integral by a sum over k point lattice to the Fourier transform of the
periodic quantity. Erroneous contributions will appear only for the vectors in
real space that belong to the reciprocal of the k point lattice, except the
origin. Moreover, the expected size of these contributions usually decreases
exponentially with the distance. So, the length of the smallest of these real
space vectors is a measure of the accuracy of the k point grid.</p>
<p>When either <a class="wikilink" href="../../input_variables/basic/#ngkpt">ngkpt</a> or <a class="wikilink" href="../../input_variables/gstate/#kptrlatt">kptrlatt</a> is defined, <a class="wikilink" href="../../input_variables/gstate/#kptrlen">kptrlen</a> is not used as
an input variable, but the length of the smallest vector will be placed in
this variable, and echoed in the output file.</p>
<p>On the other hand, when neither <a class="wikilink" href="../../input_variables/basic/#ngkpt">ngkpt</a> nor <a class="wikilink" href="../../input_variables/gstate/#kptrlatt">kptrlatt</a> are defined, ABINIT
will automatically generate a large set of possible k point grids, and select
among this set, the grids that give a length of smallest vector LARGER than
<a class="wikilink" href="../../input_variables/gstate/#kptrlen">kptrlen</a>, and among these grids, the one that, when used with <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a>=1,
reduces to the smallest number of k points. Note that this procedure can be
time-consuming. It is worth doing it once for a given unit cell and set of
symmetries, but not use this procedure by default. The best is then to set
<a class="wikilink" href="../../input_variables/files/#prtkpt">prtkpt</a>=1, in order to get a detailed analysis of the set of grids.</p>
<p>If some layer of vacuum is detected in the unit cell (see the input variable
<a class="wikilink" href="../../input_variables/gstate/#vacuum">vacuum</a>), the computation of <a class="wikilink" href="../../input_variables/gstate/#kptrlen">kptrlen</a> will ignore the dimension related
to the direction perpendicular to the vacuum layer, and generate a bi-
dimensional k point grid. If the system is confined in a tube, a one-
dimensional k point grid will be generated. For a cluster, this procedure will
only generate the Gamma point.</p>
<hr />
<h2 id="magcon_lambda"><strong>magcon_lambda</strong><a class="headerlink" href="#magcon_lambda" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> MAGnetization CONstraint LAMBDA parameter<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/MagMom">MagMom</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 10.0<br />
Test list:</p>
<ul>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t05.in" title="Test magnetic constraint code. Variables magconon and magcon_lambda. BCC iron with low cutoff and kpts,  non collinear spin case with nspden=4 imposed. First normal case then constrain direction only (DS2) and full value of vector (DS3)">tests/v7/Input/t05.in</a></li>
</ul>
<p>This variable gives the amplitude of the constraint imposed on the
magnetization vectors on each atom (turned on with flag variable
<a class="wikilink" href="../../input_variables/gstate/#magconon">magconon</a>). Typical values for lambda are 10 to a few hundred. The energy
will vary strongly and convergence will be difficult if lambda is too large.
The constraint will be weak and the magnetization will not be close to
<a class="wikilink" href="../../input_variables/gstate/#spinat">spinat</a> if lambda is too small. See variable <a class="wikilink" href="../../input_variables/gstate/#magconon">magconon</a> for more details.</p>
<hr />
<h2 id="magconon"><strong>magconon</strong><a class="headerlink" href="#magconon" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> turn MAGnetization CONstraint ON<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/MagMom">MagMom</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0<br />
Test list:</p>
<ul>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t05.in" title="Test magnetic constraint code. Variables magconon and magcon_lambda. BCC iron with low cutoff and kpts,  non collinear spin case with nspden=4 imposed. First normal case then constrain direction only (DS2) and full value of vector (DS3)">tests/v7/Input/t05.in</a></li>
</ul>
<p>Turns on the imposition of a Lagrangian constraint on the magnetization. For
each atom, the magnetization is calculated in a sphere (radius <a class="wikilink" href="../../input_variables/gstate/#ratsph">ratsph</a>) and
a constraint is applied to bring it closer to the input values of <a class="wikilink" href="../../input_variables/gstate/#spinat">spinat</a>.
The constraint can be either on the direction only (magconon 1) or on the full
vector (magconon 2). The Lagrangian constraint has an amplitude
<a class="wikilink" href="../../input_variables/gstate/#magcon_lambda">magcon_lambda</a> which should be neither too big (bad or impossible
convergence) nor too small (no effect).</p>
<hr />
<h2 id="mixalch"><strong>mixalch</strong><a class="headerlink" href="#mixalch" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> MIXing coefficients for ALCHemical potentials<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/AtomTypes">AtomTypes</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> (<a class="wikilink" href="../../input_variables/gstate/#npspalch">npspalch</a>,<a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a>)<br />
<em>Default value:</em> None<br />
Test list:</p>
<ul>
<li>v3:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t92.in" title="Linear chain of X2 molecules (2 atoms per unit cell), using alchemical atoms (well,  with no mixing,  just for a test) Computation of the second derivative of the total energy with respect to a atomic displacement perpendicular to the chain,  with q(0 0 1/2) wavevector. The first psp is Si,  the second one is Ge,  but the mixing coefficients are 1.0 and 0.0 . See test 4 of v2,  except with alchemy.">tests/v3/Input/t92.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t93.in" title="Linear chain of X2 molecules (2 atoms per unit cell), using alchemical atoms,  GS only. The first psp is Ge,  the second one is Si,  but the mixing coefficients are 0.0 and 1.0 . See previous test,  except GS only,  and the two atoms are switched.">tests/v3/Input/t93.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t94.in" title="Linear chain of X2 molecules (2 atoms per unit cell), using alchemical atoms,  GS only. The first psp is Si,  the second one is Si,  the mixing coefficients are 0.2 and 0.8,  then,  in a second dataset,  they are 0.5 and 0.5 . Should give same numerical results as the previous test.">tests/v3/Input/t94.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t95.in" title="Linear chain of X2 molecules (2 atoms per unit cell), using alchemical atoms,  GS only. The first psp is Si,  the second one is Ge,  the mixing coefficients are 0.2 and 0.8,  then 0.5 and 0.5,  then 0.001 and 0.999 .">tests/v3/Input/t95.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t96.in" title="Linear chain of X2 molecules (2 atoms per unit cell), using alchemical atoms,  GS only. The first psp is Si,  the second one is Ge,  the mixing coefficients are 0.5 and 0.5 . The pseudopotentials differ from the ones of test #93 .">tests/v3/Input/t96.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t97.in" title="Fake MoSixO(1-x) molecule along the diagonal of a cube, using alchemical pseudopotentials. Si and O are not isovalent,  so might not be physically meaningful. 4 pairs of mixing coefficients are studied,  including one for which the occupation numbers becomes fractionary.">tests/v3/Input/t97.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t44.in" title="Bismuth atom,  isolated,  in a supercell. Try alchemical pseudopotentials with spin-orbit. Spinor calculation (nspinor=2,  nspden=1,  nsppol=1) Metallic occupations. Also compare the halved spin-orbit interaction alchemical mixing with a pseudopotential directly prepared with halved spin-orbit interaction. The agreement is perfect.">tests/v5/Input/t44.in</a></li>
<li>v6:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t28.in" title="Ga Al(1-x) Asx Test of alchemical calculations with images. Mostly checking the treatment of input variables and their echo. (Tests 30-36 are more slots for testing the ground state)">tests/v6/Input/t28.in</a></li>
</ul>
<p>Used for the generation of alchemical pseudoatoms, that is, when <a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a>
is non-zero.</p>
<p>This array gives, for each type of alchemical pseudatom (there are
<a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a> such pseudoatoms), the mixing coefficients of the basic
<a class="wikilink" href="../../input_variables/gstate/#npspalch">npspalch</a> pseudopotentials for alchemical use. For each type of alchemical
pseudoatom, the sum of the mixing coefficients must equal 1.</p>
<p>The actual use of the mixing coefficients is defined by the input variable
<a class="wikilink" href="../../input_variables/gstate/#algalch">algalch</a>. Note that the masses of the atoms, <a class="wikilink" href="../../input_variables/rlx/#amu">amu</a> are also mixed
according to the value of <a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a>, by default.</p>
<p>Example 1. Suppose that we want to describe Ba(0.25) Sr(0.75) Ti O3.<br />
The input variables related to the construction of the alchemical Ba(0.25)
Sr(0.75) potential will be :</p>
<pre><code>  npsp   4                 ! 4 pseudopotentials should be read.
  znucl  8 40 56 38        ! The nuclear charges. Note that the two
                           ! atoms whose pseudopotentials are to be mixed
                           ! are mentioned at the end of the series.
  ntypat  3                ! There will be three types of atoms.
  ntypalch   1             ! One pseudoatom will be alchemical.
                           ! Hence, there will be ntyppure=2 pure pseudoatoms,
                           ! with znucl 8 (O) and 40 (Ti), corresponding to
                           ! the two first pseudopotentials. Out of the
                           ! four pseudopotentials, npspalch=2 are left
                           ! for alchemical purposes, with znucl 56 (Ba)
                           ! and 38 (Sr).
  mixalch    0.25  0.75    ! For that unique pseudoatom to be
                           ! generated, here are the mixing coeeficients,
                           ! to be used to combine the Ba and Sr pseudopotentials.
</code></pre>
<p>Example 2. More complicated, and illustrate some minor drawback of the design
of input variables. Suppose that one wants to generate Al(0.25)Ga(0.75)
As(0.10)Sb(0.90).<br />
The input variables will be :</p>
<pre><code>  npsp  4                  ! 4 pseudopotentials should be read
  znucl  13 31 33 51       ! The atomic numbers. All pseudopotentials
                           ! will be used for some alchemical purpose
  ntypat  2                ! There will be two types of atoms.
  ntypalch   2             ! None of the atoms will be "pure".
                           ! Hence, there will be npspalch=4 pseudopotentials
                           !  to be used for alchemical purposes.
  mixalch    0.25  0.75 0.0  0.0   ! This array is a (4,2) array, arranged in the
             0.0   0.0  0.1  0.9   ! usual Fortran order.
</code></pre>
<p>Minor drawback : one should not forget to fill <a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a> with the needed
zero's, in this later case.</p>
<p>In most cases, the use of <a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a> will be as a static (non-evolving)
variable. However, the possibility to have different values of <a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a> for
different images has been coded. A population of cells with different atomic
characteristics can thus be considered, and can be made to evolve, e.g. with a
genetic algorithm (not coded in v7.0.0 though). There is one restriction to
this possibility : the value of <a class="wikilink" href="../../input_variables/internal/#ziontypat">ziontypat</a> for the atoms that are mixed
should be identical.</p>
<hr />
<h2 id="natsph"><strong>natsph</strong><a class="headerlink" href="#natsph" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of ATomic SPHeres for the atom-projected density-of-states<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/printing">printing</a>, <a class="wikilink" href="../../topics/ElecBandStructure">ElecBandStructure</a>, <a class="wikilink" href="../../topics/ElecDOS">ElecDOS</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> <a class="wikilink" href="../../input_variables/basic/#natom">natom</a><br />
<em>Only relevant if:</em> <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a> == 3 or <a class="wikilink" href="../../input_variables/paw/#pawfatbnd">pawfatbnd</a> in [1,2]<br />
Test list:</p>
<ul>
<li>mpiio:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/mpiio/Input/t26.in" title="C-diamond,  Bulk,  2 atoms,  with PAW. Test the IO routines with paral_kgb in [1,  0] and different combinations of parameters (npfft,  npband,  npkpt). Test the plane wave load balancing procedure (pw_unbal_thresh). Test also the computation of PJDOS.">tests/mpiio/Input/t26.in</a></li>
<li>tutorial:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpaw1_4.in" title="Input for PAW1 tutorial Diamond at experimental volume">tests/tutorial/Input/tpaw1_4.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tspin_3.in" title="Fe fcc structure with two atoms per unit cell for test of antiferromagnetic This is the simplest fcc structure compatible with a X point spiral">tests/tutorial/Input/tspin_3.in</a></li>
<li>v4:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v4/Input/t38.in" title="Test the computation of the partial DOS,  using the linear tetrahedron method. 2 Silicon atoms,  in a diamond structure.">tests/v4/Input/t38.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t19.in" title="FCC Gadolinium. PAW + U calculation Test the imposition of the density matrix (10 first steps) and related variables. Test of partial DOS is also done (through the diff of DOS_AT0001)">tests/v5/Input/t19.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t20.in" title="NiO antiferromagnetic. Test of prtfatbnd==2 2 Ni and 2 O atoms in an fcc supercell. The cut-offs are unrealistic. The aim of this test is to verify: * Computation of band structure in PAW+U * Calculation of partial DOS (diffs of partial DOS is not done) * Calculation of Fatbands (diff of a fatband file is done)">tests/v5/Input/t20.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t40.in" title="Density from test 38 is read;  then a non self-consistent calculation is done and the m-decomposed LDOS on the first atom is printed out.">tests/v5/Input/t40.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t04.in" title="Test natsph_extra,  ratsph_extra,  and xredsph_extra for STS calculation. Al (111) surface slab with very low ecut and ngkpt in the plane.">tests/v7/Input/t04.in</a></li>
</ul>
<p><a class="wikilink" href="../../input_variables/gstate/#natsph">natsph</a> gives the number of atoms around which the sphere for atom-
projected density-of-states will be built, in the <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a>=3 case. The
indices of these atoms are given by <a class="wikilink" href="../../input_variables/gstate/#iatsph">iatsph</a>. The radius of these spheres is
given by <a class="wikilink" href="../../input_variables/gstate/#ratsph">ratsph</a>.<br />
If <a class="wikilink" href="../../input_variables/paw/#pawfatbnd">pawfatbnd</a>=1 or 2, it gives the number of atoms around which atom-
projected band structure will be built (the indices of these atoms are given
by <a class="wikilink" href="../../input_variables/gstate/#iatsph">iatsph</a>).</p>
<hr />
<h2 id="natsph_extra"><strong>natsph_extra</strong><a class="headerlink" href="#natsph_extra" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of ATomic SPHeres for the l-projected density-of-states in EXTRA set<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/printing">printing</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0<br />
<em>Only relevant if:</em> <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a> == 3 or <a class="wikilink" href="../../input_variables/paw/#pawfatbnd">pawfatbnd</a> in [1,2]<br />
Test list:</p>
<ul>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t04.in" title="Test natsph_extra,  ratsph_extra,  and xredsph_extra for STS calculation. Al (111) surface slab with very low ecut and ngkpt in the plane.">tests/v7/Input/t04.in</a></li>
</ul>
<p><a class="wikilink" href="../../input_variables/gstate/#natsph_extra">natsph_extra</a> gives the number of extra spheres for which the angular-
momentum-projected density-of-states will be built, in the <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a>=3 case.
The radius of these spheres is given by <a class="wikilink" href="../../input_variables/gstate/#ratsph_extra">ratsph_extra</a>. This simulates the
STS signal for an STM tip atom placed at the sphere position, according to the
chemical nature of the tip (s- p- d- wave etc...).<br />
If <a class="wikilink" href="../../input_variables/paw/#pawfatbnd">pawfatbnd</a>=1 or 2, it gives the number of spheres in which l-projected
band structure will be built.<br />
The position of the spheres is given by the <a class="wikilink" href="../../input_variables/gstate/#xredsph_extra">xredsph_extra</a> variable.</p>
<hr />
<h2 id="nbdbuf"><strong>nbdbuf</strong><a class="headerlink" href="#nbdbuf" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of BanDs for the BUFfer<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/SCFControl">SCFControl</a>, <a class="wikilink" href="../../topics/BandOcc">BandOcc</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 2<em><a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a> if <a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a>==0 and <a class="wikilink" href="../../input_variables/basic/#iscf">iscf</a>&lt;0,
2</em><a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a> if <a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a>==1 and 3&lt;=<a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a> and <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>&lt;= 8,
0 otherwise.</p>
<p><a class="wikilink" href="../../input_variables/gstate/#nbdbuf">nbdbuf</a> gives the number of bands, the highest in energy, that, among the
<a class="wikilink" href="../../input_variables/basic/#nband">nband</a> bands, are to be considered as part of a buffer. This concept is
useful in three situations: in non-self-consistent calculations, for the
determination of the convergence tolerance ; for response functions of metals,
to avoid instabilities, and also when finite electric fields or non-linear
responses (with electric field perturbations) are considered. For the two
first, the need of a buffer is a natural requirement of the problem, so that
the default value is changed to 2 automatically, as explained in the
following. The third case is only for implementation convenience.</p>
<p>In non-self-consistent GS calculations (<a class="wikilink" href="../../input_variables/basic/#iscf">iscf</a>&lt;0), the highest levels
might be difficult to converge, if they are degenerate with another level,
that does not belong to the set of bands treated. Then, it might take
extremely long to reach <a class="wikilink" href="../../input_variables/basic/#tolwfr">tolwfr</a>, although the other bands are already
extremely well-converged, and the energy of the highest bands (whose residual
are not yet good enough), is also rather well converged.<br />
In response to this problem, for non-zero <a class="wikilink" href="../../input_variables/gstate/#nbdbuf">nbdbuf</a>, the largest residual
(residm), to be later compared with <a class="wikilink" href="../../input_variables/basic/#tolwfr">tolwfr</a>, will be computed only in the
set of non-buffer bands (this modification applies for non-self-consistent as
well as self-consistent calculation, for GS as well as RF calculations).<br />
For a GS calculation, with <a class="wikilink" href="../../input_variables/basic/#iscf">iscf</a>&lt;0, supposing <a class="wikilink" href="../../input_variables/gstate/#nbdbuf">nbdbuf</a> is not
initialized in the input file, then ABINIT will overcome the default
<a class="wikilink" href="../../input_variables/gstate/#nbdbuf">nbdbuf</a> value, and automatically set <a class="wikilink" href="../../input_variables/gstate/#nbdbuf">nbdbuf</a> to 2.</p>
<p>In metallic RF calculations, in the conjugate gradient optimisation of first-
order wavefunctions, there is an instability situation when the q wavevector
of the perturbation brings the eigenenergy of the highest treated band at some
k point higher than the lowest untreated eigenenergy at some k+q point. If one
accepts a buffer of frozen states, this instability can be made to disappear.
Frozen states receive automatically a residual value of -0.1d0.<br />
For a RF calculation, with 3&lt;=<a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>&lt;=7, supposing <a class="wikilink" href="../../input_variables/gstate/#nbdbuf">nbdbuf</a> is not
initialized in the input file, then ABINIT will overcome the default
<a class="wikilink" href="../../input_variables/gstate/#nbdbuf">nbdbuf</a> value, and automatically set <a class="wikilink" href="../../input_variables/gstate/#nbdbuf">nbdbuf</a> to 2. This value might be
too low in some cases.</p>
<p>Also, the number of active bands, in all cases, is imposed to be at least 1,
irrespective of the value of <a class="wikilink" href="../../input_variables/gstate/#nbdbuf">nbdbuf</a>.</p>
<hr />
<h2 id="ndivk"><strong>ndivk</strong><a class="headerlink" href="#ndivk" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of DIVisions of K lines<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/k-points">k-points</a>, <a class="wikilink" href="../../topics/ElecBandStructure">ElecBandStructure</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (abs(<a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a>))<br />
<em>Default value:</em> None<br />
<em>Comment:</em> Will be generated automatically from <a class="wikilink" href="../../input_variables/gstate/#ndivsm">ndivsm</a> if the latter is defined.<br />
<em>Only relevant if:</em> <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> &lt; 0<br />
<em>The use of this variable forbids the use of:</em> specified(<a class="wikilink" href="../../input_variables/gstate/#ndivsm">ndivsm</a>)<br />
Test list:</p>
<ul>
<li>tutorial:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tbase3_5.in" title="Crystalline silicon Computation of the band structure. First,  a SCF density computation,  then a non-SCF band structure calculation.">tests/tutorial/Input/tbase3_5.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tfold2bloch_1.in" title="H6 Supercell Generates a 6 atom Hydrogen supercell with the multiplicity of 1:2:3 (x:y:z) Produce WFK file to be analyzed with fold2bloch">tests/tutorial/Input/tfold2bloch_1.in</a></li>
<li>v2:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v2/Input/t43.in" title="BCC Molybdenum. Test the k point generator : Monkhorst-Pack grid,  then band structure.">tests/v2/Input/t43.in</a></li>
<li>v4:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v4/Input/t89.in" title="Au linear chain. Test the output of a launch.dat file for WanT Note: the file that is produced is not tested, Only the usual output file of ABINIT. Want output does not support MPI with ncpus &gt; 1.">tests/v4/Input/t89.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t20.in" title="NiO antiferromagnetic. Test of prtfatbnd==2 2 Ni and 2 O atoms in an fcc supercell. The cut-offs are unrealistic. The aim of this test is to verify: * Computation of band structure in PAW+U * Calculation of partial DOS (diffs of partial DOS is not done) * Calculation of Fatbands (diff of a fatband file is done)">tests/v5/Input/t20.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t54.in" title="Crystalline Silicon to test the CP2K pseudopotential implementation with the new pseudo type: pspcod 10 (same formalism as HGH pseudos,  pspcod 3). Same input file as t35.in of tests/tutorial,  the only difference is that in the test the used pseudo is taken from the CP2K library. (http://cvs.berlios.de/cgi-bin/viewcvs.cgi/cp2k/potentials/Goedecker/abinit/) The bandstructure is in agreement with that calculated in the tutorial example with the pspcod=1 pseudopotential.">tests/v5/Input/t54.in</a></li>
<li>v6:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t34.in" title="Crystalline silicon. Diamond structure. Quick test of the use of datasets with a numbering beyond 1000 (the last one is 1022). (Tests 35-40 are for response-function)">tests/v6/Input/t34.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t71.in" title="Calculation of Projected Wannier functions and compute band structure in the d orbital Wannier basis">tests/v7/Input/t71.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t72.in" title="Calculation of Projected Wannier functions and compute a simplified interpolated band structure">tests/v7/Input/t72.in</a></li>
</ul>
<p>Gives the number of divisions of each of the segments of the band structure,
whose path is determined by <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> and <a class="wikilink" href="../../input_variables/gstate/#kptbounds">kptbounds</a>. In this case, the
absolute value of <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> is the number of such segments.</p>
<p>For example, suppose that the number of segment is just one (<a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a>=-1), a
value <a class="wikilink" href="../../input_variables/gstate/#ndivk">ndivk</a>=4 will lead to the computation of points with relative
coordinates 0.0, 0.25, 0.5, 0.75 and 1.0 , along the segment in consideration.</p>
<p>Now, suppose that there are two segments (<a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a>=-2), with <a class="wikilink" href="../../input_variables/gstate/#ndivk">ndivk</a>(1)=4
and <a class="wikilink" href="../../input_variables/gstate/#ndivk">ndivk</a>(2)=2, the computation of the eigenvalues will be done at 7
points, 5 belonging to the first segment, with relative coordinates 0.0, 0.25,
0.5, 0.75 and 1.0, the last one being also the starting point of the next
segment, for which two other points must be computed, with relative
coordinates 0.5 and 1.0 .</p>
<p>It is easy to compute disconnected circuits (non-chained segments), by
separating the circuits with the value <a class="wikilink" href="../../input_variables/gstate/#ndivk">ndivk</a>=1 for the intermediate
segment connecting the end of one circuit with the beginning of the next one
(in which case no intermediate point is computed along this segment).</p>
<p>Alternatively it is possible to generate automatically the array <a class="wikilink" href="../../input_variables/gstate/#ndivk">ndivk</a> by
just specifying the number of divisions for the smallest segment. See the
related input variable <a class="wikilink" href="../../input_variables/gstate/#ndivsm">ndivsm</a>.</p>
<hr />
<h2 id="ndivsm"><strong>ndivsm</strong><a class="headerlink" href="#ndivsm" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of DIVisions for the SMallest segment<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/k-points">k-points</a>, <a class="wikilink" href="../../topics/ElecBandStructure">ElecBandStructure</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> None<br />
Test list:</p>
<ul>
<li>libxc:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/libxc/Input/t42.in" title="Diamond: hybrid functional calculation with the GW code Self-consistent approach to the HSE06 band structure based on a unitary transform of a subset of LDA wavefunctions">tests/libxc/Input/t42.in</a></li>
<li>tutorespfn:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorespfn/Input/tdepes_4.in" title="Temperature dependence calculation of diamond.">tests/tutorespfn/Input/tdepes_4.in</a></li>
<li>v6:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t14.in" title="MgB2,  space group P6/m m m (#191);  Bravais hP (primitive hexag.) GS calculation followed by a band structure calculation in which the k-path is automatically defined via the ndivsm input variable. The third dataset tests the calculation and the output of the Fermi surface (prtfsurf=1) in the Xcrysden format.">tests/v6/Input/t14.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t88.in" title="Calculation of phonon linewidths and e-ph coupling parameter lambda.">tests/v7/Input/t88.in</a></li>
<li>v8:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v8/Input/t04.in" title="Interpolation of electronic bands with two different techniques (star functions and B-spline interpolation)">tests/v8/Input/t04.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v8/Input/t44.in" title="WARNING: This code is still under development. Use at your own risk. Calculation of the Fan-Migdal + Debye-Waller self-energy matrix elements.">tests/v8/Input/t44.in</a></li>
</ul>
<p>This variable defines the number of divisions used to sample the smallest
segment of the circuit employed in a band structure calculations (see related
input variables <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> and <a class="wikilink" href="../../input_variables/gstate/#kptbounds">kptbounds</a>). If <a class="wikilink" href="../../input_variables/gstate/#ndivsm">ndivsm</a> is given in the
input file, there is no need to specify the number of divisions to be used for
the other segments. Indeed <a class="wikilink" href="../../input_variables/gstate/#ndivk">ndivk</a> is automatically calculated inside the
code in order to generate a path where the number of divisions in each segment
is proportional to the length of the segment itself. This option is activated
only when <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> is negative. In this case, the absolute value of
<a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> is the number of such segments.</p>
<hr />
<h2 id="ngfft"><strong>ngfft</strong><a class="headerlink" href="#ngfft" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of Grid points for Fast Fourier Transform<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Planewaves">Planewaves</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (3)<br />
<em>Default value:</em> [0, 0, 0]<br />
<em>Comment:</em> (automatic selection of optimal values)  </p>
<p>gives the size of fast Fourier transform (fft) grid in three dimensions. Each
number must be composed of the factors 2, 3, and 5 to be consistent with the
radices available in our fft. If no <a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a> is provided or if <a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a> is
set to 0 0 0, the code will automatically provide an optimal set of <a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>
values, based on <a class="wikilink" href="../../input_variables/basic/#acell">acell</a>, <a class="wikilink" href="../../input_variables/basic/#rprim">rprim</a> and <a class="wikilink" href="../../input_variables/basic/#ecut">ecut</a> (see also <a class="wikilink" href="../../input_variables/gstate/#boxcutmin">boxcutmin</a> for
speed/accuracy concerns). This is the recommended procedure, of course.<br />
The total number of FFT points is the product:<br />
<a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(1)<em><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(2)</em><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(3)=nfft  .<br />
When <a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a> is made smaller than recommended values (e.g. by setting
<a class="wikilink" href="../../input_variables/gstate/#boxcutmin">boxcutmin</a> to a value smaller than 2.0 or by setting <a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a> manually),
the code runs faster and the equations in effect are approximated by a low
pass Fourier filter. The code reports to standard output (unit 06) a parameter
"boxcut" which is the smallest ratio of the fft box side to the G vector basis
sphere diameter. When boxcut is less than 2 the Fourier filter approximation
is being used. When boxcut gets less than about 1.5 the approximation may be
too severe for realistic results and should be tested against larger values of
<a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>. When boxcut is larger than 2, <a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a> could be reduced without
loss of accuracy. In this case, the small variations that are observed are
solely due to the xc quadrature, that may be handled with <a class="wikilink" href="../../input_variables/dev/#intxc">intxc</a>=1 to even
reduce this effect.</p>
<p>Internally, <a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a> is an array of size 18. The present components are
stored in <a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(1:3), while</p>
<ul>
<li><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(4:6) contains slightly different (larger) values, modified for efficiency of the FFT </li>
<li><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(7) is <a class="wikilink" href="../../input_variables/dev/#fftalg">fftalg</a> </li>
<li><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(8) is <a class="wikilink" href="../../input_variables/dev/#fftcache">fftcache</a> </li>
<li><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(9) is set to 0 if the parallelization of the FFT is not activated, while it is set to 1 if it is activated. </li>
<li><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(10) is the number of processors of the FFT group </li>
<li><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(11) is the index of the processor in the group of processors </li>
<li><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(12) is n2proc, the number of x-z planes, in reciprocal space, treated by the processor </li>
<li><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(13) is n3proc, the number of x-y planes, in real space, treated by the processor </li>
<li><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(14) is mpi_comm_fft, the handle on the MPI communicator in charge of the FFT parallelisation </li>
<li><a class="wikilink" href="../../input_variables/gstate/#ngfft">ngfft</a>(15:18) are not yet used </li>
</ul>
<p>The number of points stored by this processor in real space is n1<em>n2</em>n3proc,
while in reciprocal space, it is n1<em>n2proc</em>n3.</p>
<hr />
<h2 id="ngqpt"><strong>ngqpt</strong><a class="headerlink" href="#ngqpt" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of Grid pointsfor Q PoinTs generation<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/q-points">q-points</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (3)<br />
<em>Default value:</em> [0, 0, 0]<br />
<em>Only relevant if:</em> <a class="wikilink" href="../../input_variables/gstate/#nqpt">nqpt</a>==1 and <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a>&gt;=0<br />
<em>The use of this variable forbids the use of:</em> specified(<a class="wikilink" href="../../input_variables/gstate/#qptrlatt">qptrlatt</a>)<br />
Test list:</p>
<ul>
<li>tutorespfn:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorespfn/Input/tdepes_3.in" title="Temperature dependence calculation of diamond.">tests/tutorespfn/Input/tdepes_3.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorespfn/Input/tdepes_4.in" title="Temperature dependence calculation of diamond.">tests/tutorespfn/Input/tdepes_4.in</a></li>
<li>v6:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t78.in" title="Generate first-order responses for FCC Aluminum. Very low cut-off,  to keep CPU the lowest possible Aim at a regular sampling of phonon wavevectors,  needed to interpolate the dynamical matrix over the whole Brillouin Zone. Use the definition through ngqpt and nshiftq. Otherwise,  similar to Tv2#26">tests/v6/Input/t78.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t50.in" title="Diamond. Test temperature-dependent of the electronic structure,  with reduction of the number of q points to be computed,  thanks to thmflag=7 . The temperature-dependent shifts must be averaged over degenerate states. This temperature-dependent calculation make use of a k-point interpolation to speed up the convergence study with respect to the q-points integration. Two q-points are computed.">tests/v7/Input/t50.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t51.in" title="This tests make use of the irdwfkfine variable instead of the getwfkfine variable used in the previous test. The third q-point is computed here.">tests/v7/Input/t51.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t57.in" title="Diamond. The wtq variable is introduced to be able to reproduce the q-point weight obtained with ngqpt and qptopt. The main reason being that the initialization of large q-point (same for k-point) grid is extremely slow. Inputing manually the qpt and wtq in the input file avoid such inefficient initialization.">tests/v7/Input/t57.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t83.in" title="O2 Oxygen spin-temperature-dependent of the band energies">tests/v7/Input/t83.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t88.in" title="Calculation of phonon linewidths and e-ph coupling parameter lambda.">tests/v7/Input/t88.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t89.in" title="Calculation of e-ph coupling matrix elements">tests/v7/Input/t89.in</a></li>
<li>v8:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v8/Input/t44.in" title="WARNING: This code is still under development. Use at your own risk. Calculation of the Fan-Migdal + Debye-Waller self-energy matrix elements.">tests/v8/Input/t44.in</a></li>
</ul>
<p>At variance with <a class="wikilink" href="../../input_variables/basic/#ngkpt">ngkpt</a>, note that only one q point is selected per dataset
(see <a class="wikilink" href="../../input_variables/gstate/#iqpt">iqpt</a>).<br />
Its three positive components give the number of q points of Monkhorst-Pack
grids (defined with respect to primitive axis in reciprocal space) in each of
the three dimensions. The use of <a class="wikilink" href="../../input_variables/gstate/#nshiftq">nshiftq</a> and <a class="wikilink" href="../../input_variables/gstate/#shiftq">shiftq</a>, allows to
generate shifted grids, or Monkhorst-Pack grids defined with respect to
conventional unit cells.</p>
<p>For more information on Monkhorst-Pack grids, see <a class="wikilink" href="../../input_variables/basic/#ngkpt">ngkpt</a>.</p>
<hr />
<h2 id="nline"><strong>nline</strong><a class="headerlink" href="#nline" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of LINE minimisations<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/SCFControl">SCFControl</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 4  </p>
<p>Gives maximum number of line minimizations allowed in preconditioned conjugate
gradient minimization for each band. The Default, 4, is fine.<br />
Special cases, with degeneracies or near-degeneracies of levels at the Fermi
energy may require a larger value of <a class="wikilink" href="../../input_variables/gstate/#nline">nline</a> (5 or 6 ?) Line minimizations
will be stopped anyway when improvement gets small. With the input variable
<a class="wikilink" href="../../input_variables/dev/#nnsclo">nnsclo</a>, governs the convergence of the wavefunctions for fixed potential.<br />
Note that <a class="wikilink" href="../../input_variables/gstate/#nline">nline</a>=0 can be used to diagonalize the Hamiltonian matrix in the
subspace spanned by the input wavefunctions.</p>
<hr />
<h2 id="npsp"><strong>npsp</strong><a class="headerlink" href="#npsp" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of PSeudoPotentials<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/AtomTypes">AtomTypes</a>, <a class="wikilink" href="../../topics/PseudosPAW">PseudosPAW</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> <a class="wikilink" href="../../input_variables/basic/#ntypat">ntypat</a>  </p>
<p>Usually, the number of pseudopotentials to be read is equal to the number of
type of atoms. However, in the case an alchemical mixing of pseudopotential is
to be used, often the number of pseudopotentials to be read will not equal the
number of types of atoms.</p>
<p>Alchemical pseudopotentials will be present when <a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a> is non-zero. See
<a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a> to understand how to use alchemical potentials in ABINIT. The
input variables (<a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a>, <a class="wikilink" href="../../input_variables/gstate/#algalch">algalch</a>,<a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a>) are active, and
generate alchemical potentials from the available pseudopotentials. Also, the
inner variables (<a class="wikilink" href="../../input_variables/gstate/#ntyppure">ntyppure</a>,<a class="wikilink" href="../../input_variables/gstate/#npspalch">npspalch</a>) become active. See these input
variables, especially <a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a>, to understand how to use alchemical
potentials in ABINIT.</p>
<hr />
<h2 id="npspalch"><strong>npspalch</strong><a class="headerlink" href="#npspalch" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of PSeudoPotentials that are "ALCHemical"<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/AtomTypes">AtomTypes</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> <a class="wikilink" href="../../input_variables/gstate/#npsp">npsp</a>-<a class="wikilink" href="../../input_variables/gstate/#ntyppure">ntyppure</a><br />
<em>Only relevant if:</em> <a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a>/=0<br />
Test list:</p>
<p>Gives the number of pseudopotentials that are used for alchemical mixing (when
<a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a> is non-zero) :</p>
<p><a class="wikilink" href="../../input_variables/gstate/#npspalch">npspalch</a>=<a class="wikilink" href="../../input_variables/gstate/#npsp">npsp</a>-<a class="wikilink" href="../../input_variables/gstate/#ntyppure">ntyppure</a></p>
<hr />
<h2 id="nqpt"><strong>nqpt</strong><a class="headerlink" href="#nqpt" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of Q - POINTs<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/q-points">q-points</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0  </p>
<p>Determines whether one q point must be read (See the variable <a class="wikilink" href="../../input_variables/internal/#qptn">qptn</a>).<br />
Can be either 0 or 1.<br />
If 1 and used in ground-state calculation, a global shift of all the k-points
is applied, to give calculation at k+q. In this case, the output wavefunction
will be appended by _WFQ instead of _WFK (see the <a href="../../../users/generated_files/help_abinit.html"> section 4
</a> of the <a class="wikilink" href="../../help_abinit/">help_abinit</a>) Also,
if 1 and a RF calculation is done, defines the wavevector of the perturbation.</p>
<hr />
<h2 id="nshiftq"><strong>nshiftq</strong><a class="headerlink" href="#nshiftq" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of SHIFTs for Q point grids<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/q-points">q-points</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1<br />
Test list:</p>
<ul>
<li>tutorespfn:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorespfn/Input/tdepes_3.in" title="Temperature dependence calculation of diamond.">tests/tutorespfn/Input/tdepes_3.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorespfn/Input/tdepes_4.in" title="Temperature dependence calculation of diamond.">tests/tutorespfn/Input/tdepes_4.in</a></li>
<li>v6:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t35.in" title="Generate first-order responses for FCC Aluminum. Very low cut-off,  to keep CPU the lowest possible Aim at a regular sampling of phonon wavevectors,  needed to interpolate the dynamical matrix over the whole Brillouin Zone. Use the definition through qptrlatt. Otherwise,  similar to Tv2#26 and Tv6#78.">tests/v6/Input/t35.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t78.in" title="Generate first-order responses for FCC Aluminum. Very low cut-off,  to keep CPU the lowest possible Aim at a regular sampling of phonon wavevectors,  needed to interpolate the dynamical matrix over the whole Brillouin Zone. Use the definition through ngqpt and nshiftq. Otherwise,  similar to Tv2#26">tests/v6/Input/t78.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t50.in" title="Diamond. Test temperature-dependent of the electronic structure,  with reduction of the number of q points to be computed,  thanks to thmflag=7 . The temperature-dependent shifts must be averaged over degenerate states. This temperature-dependent calculation make use of a k-point interpolation to speed up the convergence study with respect to the q-points integration. Two q-points are computed.">tests/v7/Input/t50.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t51.in" title="This tests make use of the irdwfkfine variable instead of the getwfkfine variable used in the previous test. The third q-point is computed here.">tests/v7/Input/t51.in</a></li>
</ul>
<p>This parameter gives the number of shifted grids to be used concurrently to
generate the full grid of q points. It can be used with primitive grids
defined either from <a class="wikilink" href="../../input_variables/gstate/#ngqpt">ngqpt</a> or <a class="wikilink" href="../../input_variables/gstate/#qptrlatt">qptrlatt</a>. The maximum allowed value of
<a class="wikilink" href="../../input_variables/gstate/#nshiftq">nshiftq</a> is 8. The values of the shifts are given by <a class="wikilink" href="../../input_variables/gstate/#shiftq">shiftq</a>.</p>
<hr />
<h2 id="nspden"><strong>nspden</strong><a class="headerlink" href="#nspden" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of SPin-DENsity components<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/spinpolarisation">spinpolarisation</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> <a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>  </p>
<p>If <a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=1, no spin-magnetization : the density matrix is diagonal, with
same values spin-up and spin-down (compatible with <a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=1 only, for both
<a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=1 or 2)</p>
<p>If <a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=2, scalar magnetization (the axis is arbitrarily fixed in the z
direction) : the density matrix is diagonal, with different values for spin-up
and spin-down (compatible with <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=1, either with <a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=2
-general collinear magnetization- or <a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=1 -antiferromagnetism)</p>
<p>If <a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=4, vector magnetization : the density matrix is full, with
allowed x, y and z magnetization (useful only with <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=2 and
<a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=1, either because there is spin-orbit without time-reversal
symmetry - and thus spontaneous magnetization, or with spin-orbit, if one
allows for spontaneous non-collinear magnetism). Not yet available for
response functions. Also note that, with <a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=4, time-reversal symmetry
is not taken into account (at present ; this has to be checked) and thus
<a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> has to be different from 1 or 2.</p>
<p>The default (<a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=<a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>) does not suit the case of vector
magnetization.</p>
<hr />
<h2 id="nspinor"><strong>nspinor</strong><a class="headerlink" href="#nspinor" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of SPINORial components of the wavefunctions<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/spinpolarisation">spinpolarisation</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 2 if <a class="wikilink" href="../../input_variables/paw/#pawspnorb">pawspnorb</a>==1,
1 otherwise.</p>
<p>If <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=1, usual case : scalar wavefunction (compatible with
(<a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=1, <a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=1) as well as (<a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=2, <a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=2) )</p>
<p>If <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=2, the wavefunction is a spinor (compatible with <a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=1,
with <a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=1 or 4, but not with <a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=2)</p>
<p>When <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a> is 2, the values of <a class="wikilink" href="../../input_variables/dev/#istwfk">istwfk</a> are automatically set to 1.
Also, the number of bands, for each k-point, should be even.</p>
<hr />
<h2 id="ntypalch"><strong>ntypalch</strong><a class="headerlink" href="#ntypalch" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of TYPe of atoms that are "ALCHemical"<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/AtomTypes">AtomTypes</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0<br />
Test list:</p>
<ul>
<li>v3:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t92.in" title="Linear chain of X2 molecules (2 atoms per unit cell), using alchemical atoms (well,  with no mixing,  just for a test) Computation of the second derivative of the total energy with respect to a atomic displacement perpendicular to the chain,  with q(0 0 1/2) wavevector. The first psp is Si,  the second one is Ge,  but the mixing coefficients are 1.0 and 0.0 . See test 4 of v2,  except with alchemy.">tests/v3/Input/t92.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t93.in" title="Linear chain of X2 molecules (2 atoms per unit cell), using alchemical atoms,  GS only. The first psp is Ge,  the second one is Si,  but the mixing coefficients are 0.0 and 1.0 . See previous test,  except GS only,  and the two atoms are switched.">tests/v3/Input/t93.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t94.in" title="Linear chain of X2 molecules (2 atoms per unit cell), using alchemical atoms,  GS only. The first psp is Si,  the second one is Si,  the mixing coefficients are 0.2 and 0.8,  then,  in a second dataset,  they are 0.5 and 0.5 . Should give same numerical results as the previous test.">tests/v3/Input/t94.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t95.in" title="Linear chain of X2 molecules (2 atoms per unit cell), using alchemical atoms,  GS only. The first psp is Si,  the second one is Ge,  the mixing coefficients are 0.2 and 0.8,  then 0.5 and 0.5,  then 0.001 and 0.999 .">tests/v3/Input/t95.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t96.in" title="Linear chain of X2 molecules (2 atoms per unit cell), using alchemical atoms,  GS only. The first psp is Si,  the second one is Ge,  the mixing coefficients are 0.5 and 0.5 . The pseudopotentials differ from the ones of test #93 .">tests/v3/Input/t96.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t97.in" title="Fake MoSixO(1-x) molecule along the diagonal of a cube, using alchemical pseudopotentials. Si and O are not isovalent,  so might not be physically meaningful. 4 pairs of mixing coefficients are studied,  including one for which the occupation numbers becomes fractionary.">tests/v3/Input/t97.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t44.in" title="Bismuth atom,  isolated,  in a supercell. Try alchemical pseudopotentials with spin-orbit. Spinor calculation (nspinor=2,  nspden=1,  nsppol=1) Metallic occupations. Also compare the halved spin-orbit interaction alchemical mixing with a pseudopotential directly prepared with halved spin-orbit interaction. The agreement is perfect.">tests/v5/Input/t44.in</a></li>
<li>v6:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t28.in" title="Ga Al(1-x) Asx Test of alchemical calculations with images. Mostly checking the treatment of input variables and their echo. (Tests 30-36 are more slots for testing the ground state)">tests/v6/Input/t28.in</a></li>
</ul>
<p>Used for the generation of alchemical pseudopotentials : when <a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a> is
non-zero, alchemical mixing will be used.</p>
<p>Among the <a class="wikilink" href="../../input_variables/basic/#ntypat">ntypat</a> types of atoms, the last <a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a> will be
"alchemical" pseudoatoms, while only the first <strong> ntyppure </strong> will be uniquely
associated with a pseudopotential (the <strong> ntyppure </strong> first of these,
actually). The <a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a> types of alchemical pseudoatoms are to be made
from the remaining <a class="wikilink" href="../../input_variables/gstate/#npspalch">npspalch</a> pseudopotentials.</p>
<p>In this case, the input variables <a class="wikilink" href="../../input_variables/gstate/#algalch">algalch</a>,<a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a> are active, and
generate alchemical potentials from the available pseudopotentials. See these
input variables, especially <a class="wikilink" href="../../input_variables/gstate/#mixalch">mixalch</a>, to understand how to use alchemical
potentials in ABINIT.</p>
<hr />
<h2 id="ntyppure"><strong>ntyppure</strong><a class="headerlink" href="#ntyppure" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of TYPe of atoms that are "PURe"<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/AtomTypes">AtomTypes</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> <a class="wikilink" href="../../input_variables/basic/#ntypat">ntypat</a>-<a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a><br />
Test list:</p>
<p>Gives the number of type of atoms that are "pure" when alchemical mixing is
used (<a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a> /= 0) :</p>
<p><a class="wikilink" href="../../input_variables/gstate/#ntyppure">ntyppure</a>=<a class="wikilink" href="../../input_variables/basic/#ntypat">ntypat</a>-<a class="wikilink" href="../../input_variables/gstate/#ntypalch">ntypalch</a></p>
<hr />
<h2 id="nucdipmom"><strong>nucdipmom</strong><a class="headerlink" href="#nucdipmom" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> NUClear DIPole MOMents<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/MagField">MagField</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> (3,<a class="wikilink" href="../../input_variables/basic/#natom">natom</a>)<br />
<em>Default value:</em> 0.0<br />
<em>Only relevant if:</em> <a class="wikilink" href="../../input_variables/internal/#usepaw">usepaw</a> = 1; <a class="wikilink" href="../../input_variables/paw/#pawcpxocc">pawcpxocc</a> = 2; <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a> &gt; 2<br />
Test list:</p>
<ul>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t32.in" title="Test presence of nuclear magnetic dipole moments on atomic sites">tests/v7/Input/t32.in</a></li>
</ul>
<p>Places an array of nuclear magnetic dipole moments on the atomic positions,
useful for computing the magnetization in the presence of nuclear dipoles and
thus the chemical shielding by the converse method. The presence of these
dipoles breaks time reversal symmetry and lowers the overall spatial symmetry.</p>
<hr />
<h2 id="nwfshist"><strong>nwfshist</strong><a class="headerlink" href="#nwfshist" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Number of WaveFunctionS HISTory<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Wavelets">Wavelets</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0<br />
Test list:</p>
<ul>
<li>bigdft:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t02.in" title="H2 molecule with default parameters. No forces are computed,  with DIIS for the direct minimisation of the wavefunctions.">tests/bigdft/Input/t02.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t06.in" title="Water molecule in a big box">tests/bigdft/Input/t06.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t07.in" title="Graphene. Test wavelet run on surface">tests/bigdft/Input/t07.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t10.in" title="H2 molecule with geometry optimisation using BFGS (test the reformating part of the code).">tests/bigdft/Input/t10.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t11.in" title="Si single atom with fractional occupation.">tests/bigdft/Input/t11.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t12.in" title="Pt single atom with semi-core electrons,  Krack pseudopotentials (pspcod = 10), and colinear spin polarisation (GGA functional).">tests/bigdft/Input/t12.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t14.in" title="Hypothetical NaTi molecule. Test the diagonalisation scheme with wavelets">tests/bigdft/Input/t14.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t16.in" title="CO molecule to test the ETSF writing of wavefunctions (need compilation with --enable-bigdft).">tests/bigdft/Input/t16.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t17.in" title="CO molecule to test the ETSF restart on wavefunctions,  without wavefunction reformating (same parameters,  still need compilation with --enable-bigdft).">tests/bigdft/Input/t17.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t18.in" title="CO molecule to test the ETSF restart inside several datasets,  also test the reformating of wavelets after wvl_hgrid changed (need compilation with --enable-bigdft).">tests/bigdft/Input/t18.in</a></li>
</ul>
<p>In the wavelet basis set, the ground state is found by direct minimisation.
The algorithm used can be either the steepest descent or the DIIS (Direct
Inversion of Iteration Space). When <a class="wikilink" href="../../input_variables/gstate/#nwfshist">nwfshist</a> = 0, the steepest descent is
used ( _ i.e. _ there is no history storage of the previous iterations). If
<a class="wikilink" href="../../input_variables/gstate/#nwfshist">nwfshist</a> is strictly positive, a DIIS is used. A typical value is 6. Using
a DIIS increases the memory required by the program since N previous
wavefunctions are stored during the electronic minimisation.</p>
<hr />
<h2 id="occ"><strong>occ</strong><a class="headerlink" href="#occ" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> OCCupation numbers<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/BandOcc">BandOcc</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> (<a class="wikilink" href="../../input_variables/basic/#nband">nband</a>)<br />
<em>Default value:</em> *0  </p>
<p>Gives occupation numbers for all bands in the problem. Needed if <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>==0
or <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>==2. Ignored otherwise. Also ignored when <a class="wikilink" href="../../input_variables/basic/#iscf">iscf</a>=-2.<br />
Typical band occupancy is either 2 or 0, but can be 1 for half-occupied band
or other choices in special circumstances.<br />
If <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a> is not 2, then the occupancies must be the same for each k
point.<br />
If <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>=2, then the band occupancies must be provided explicitly for
each band, EACH k POINT, and EACH SPIN-POLARIZATION, in an array which runs
over all bands, k points, and spin-polarizations.<br />
The order of entries in the array would correspond to all bands at the first k
point (spin up), then all bands at the second k point (spin up), etc, then all
k-points spin down.<br />
The total number of array elements which must be provided is<br />
( <a class="wikilink" href="../../input_variables/basic/#nband">nband</a>(1)+<a class="wikilink" href="../../input_variables/basic/#nband">nband</a>(2)+...+ <a class="wikilink" href="../../input_variables/basic/#nband">nband</a>(<a class="wikilink" href="../../input_variables/basic/#nkpt">nkpt</a>) ) * <a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a> .<br />
The occupation numbers evolve only for metallic occupations, that is,
<a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>  3 .</p>
<hr />
<h2 id="optdriver"><strong>optdriver</strong><a class="headerlink" href="#optdriver" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> OPTions for the DRIVER<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/nonlinear">nonlinear</a>, <a class="wikilink" href="../../topics/GWls">GWls</a>, <a class="wikilink" href="../../topics/ElPhonInt">ElPhonInt</a>, <a class="wikilink" href="../../topics/GW">GW</a>, <a class="wikilink" href="../../topics/BSE">BSE</a>, <a class="wikilink" href="../../topics/DFPT">DFPT</a>, <a class="wikilink" href="../../topics/Susceptibility">Susceptibility</a>, <a class="wikilink" href="../../topics/SelfEnergy">SelfEnergy</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0  </p>
<p>For each dataset, choose the task to be done, at the level of the "driver"
routine.</p>
<p>The choice is among :<br />
<a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a>=0 : ground-state calculation (GS), routine "gstate"<br />
<a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a>=1 : response-function calculation (RF), routine "respfn"<br />
<a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a>=2 : susceptibility calculation (SUS), routine "suscep"<br />
<a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a>=3 : susceptibility and dielectric matrix calculation (SCR),
routine "screening"<br />
(see the input variables <a class="wikilink" href="../../input_variables/gw/#ecutwfn">ecutwfn</a>, <a class="wikilink" href="../../input_variables/gw/#ecuteps">ecuteps</a>, <a class="wikilink" href="../../input_variables/gw/#ppmfrq">ppmfrq</a>, <a class="wikilink" href="../../input_variables/files/#getwfk">getwfk</a>, as
well as <a class="wikilink" href="../../input_variables/gw/#nbandkss">nbandkss</a> and <a class="wikilink" href="../../input_variables/basic/#nband">nband</a>)<br />
<a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a>=4 : self-energy calculation (SIG), routine "sigma"<br />
<a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a>=5 : non-linear response functions (NONLINEAR), using the 2n+1
theorem, routine "nonlinear"<br />
<a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a> =7: electron-phonon coupling (EPH)<br />
<a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a> =66: GW using Lanczos-Sternheimer, see input variables whose
name start with gwls_* .<br />
<a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a>=99 : Bethe-Salpeter calculation (BSE), routine "bethe_salpeter"</p>
<p>If one of <a class="wikilink" href="../../input_variables/dfpt/#rfphon">rfphon</a>, <a class="wikilink" href="../../input_variables/dfpt/#rfddk">rfddk</a>, <a class="wikilink" href="../../input_variables/dfpt/#rfelfd">rfelfd</a>, or <a class="wikilink" href="../../input_variables/dfpt/#rfstrs">rfstrs</a> is non-zero, while
<a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a> is not defined in the input file, ABINIT will set <a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a>
to 1 automatically. These input variables (<a class="wikilink" href="../../input_variables/dfpt/#rfphon">rfphon</a>, <a class="wikilink" href="../../input_variables/dfpt/#rfddk">rfddk</a>, <a class="wikilink" href="../../input_variables/dfpt/#rfelfd">rfelfd</a>,
and <a class="wikilink" href="../../input_variables/dfpt/#rfstrs">rfstrs</a>) must be zero if <a class="wikilink" href="../../input_variables/gstate/#optdriver">optdriver</a> is not set to 1.</p>
<hr />
<h2 id="optstress"><strong>optstress</strong><a class="headerlink" href="#optstress" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> OPTion for the computation of STRESS<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/ForcesStresses">ForcesStresses</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1  </p>
<p>If set to 1, the computation of stresses is done, in the SCF case (under the
conditions <a class="wikilink" href="../../input_variables/basic/#iscf">iscf</a> &gt; 0 , <a class="wikilink" href="../../input_variables/files/#prtstm">prtstm</a>==0 , <a class="wikilink" href="../../input_variables/gstate/#positron">positron</a>==0, and either
<a class="wikilink" href="../../input_variables/basic/#nstep">nstep</a> &gt;0 , or <a class="wikilink" href="../../input_variables/internal/#usepaw">usepaw</a>==0 or <a class="wikilink" href="../../input_variables/files/#irdwfk">irdwfk</a>==1).<br />
Otherwise, to save CPU time, if no optimization of the cell is required, one
can skip the computation of stresses. The CPU time saving might be interesting
for some PAW calculations.</p>
<hr />
<h2 id="posdoppler"><strong>posdoppler</strong><a class="headerlink" href="#posdoppler" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> POSitron computation of DOPPLER broadening<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/positron">positron</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0<br />
Test list:</p>
<ul>
<li>tutorial:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_5.in" title="Fifth step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_5.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_7.in" title="Sixth step (part 2) of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_7.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t35.in" title="Test of the computation of the electron-positron Doppler broadening (using the two-component DFT) within PAW. A cubic box with 4 Al atoms at experimental volume. Low cut-offs,  few k-points. Computes the positron lifetime and well as the electron-positron pairs momentum distributions,  after the SCF iterations.">tests/v7/Input/t35.in</a></li>
</ul>
<p>Relevant only when <a class="wikilink" href="../../input_variables/gstate/#positron">positron</a>&lt;&gt;0.<br />
This input parameter activates the calculation of the Doppler broadening of
the electron-positron annihilation radiation.<br />
An output file containing the momentum distributions of annihilating electron-
positron pairs is created.<br />
Such a computation needs a core wave-function file (per atom type) to be
provided. This core WF file should be named '&lt;psp_file_name&gt;.corewf'
(where &lt;pspfile_name&gt; is the name of the pseudo-potential (or PAW) file)
or 'corewf.abinit&lt;ityp&gt;' (where &lt;ityp&gt; is the index of the atom
type). Core WF files can be obtained with the atompaw tool by the use of
'prtcorewf' keyword.</p>
<hr />
<h2 id="positron"><strong>positron</strong><a class="headerlink" href="#positron" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> POSITRON calculation<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/positron">positron</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0  </p>
<p>This input parameter can be positive or negative.<br />
Negative values for <a class="wikilink" href="../../input_variables/gstate/#positron">positron</a> are only relevant for PAW calculations.<br />
Electron-positron correlation functional is defined by <a class="wikilink" href="../../input_variables/gstate/#ixcpositron">ixcpositron</a>.<br />
Other relevant input parameter: <a class="wikilink" href="../../input_variables/gstate/#posocc">posocc</a> (occupation number for the
positron).  </p>
<p><em>Positive values for <a class="wikilink" href="../../input_variables/gstate/#positron">positron</a>:</em><br />
<em>For <strong><a class="wikilink" href="../../input_variables/gstate/#positron">positron</a>=1 or 2</strong>, will perform the calculation of positron
lifetime (and annihilation rate).</em>  </p>
<ul>
<li><a class="wikilink" href="../../input_variables/gstate/#positron">positron</a>=1<strong>:<br />
Starting from a previous electronic GS density (with </strong><a class="wikilink" href="../../input_variables/gstate/#positron">positron</a>=0**), a
positronic ground-state calculation is performed, considering that the
electrons are not perturbed by the presence of the positron.<br />
This is almost correct for a positron in a perfect bulk material. But this
approximation fails when defects exist in the material (for instance: the
positron might be trapped by a vacancy).<br />
The electronic density will be automatically read from a _DEN file (with or
without <a class="wikilink" href="../../input_variables/files/#irdden">irdden</a> keyword).<br />
At the end of the SCF cycle, the positron lifetime and annihilation rate are
printed out.  </li>
</ul>
<p>_Additional information for the use of pseudopotentials:  </p>
<pre><code>* PAW datasets: nothing to do; simply use usual electronic PAW datasets 
* Norm-conserving pseudopotentials: One has to use specific pseudopotentials for the positron calculation. They must be of the FHI type (pspcod=6), and must contain at their end, the all-electrons core density generated with FHI98PP. They must have lmax=lloc=0 (check that this works for the electronic GS !! No ghost, etc ...). Otherwise, their are similar to an usual FHI pseudopotential.
</code></pre>
<p>_  </p>
<ul>
<li><strong>positron=2</strong>:<br />
Starting from a previous positronic GS density (with <strong>positron=1</strong>), an
electronic ground-state calculation is performed, keeping the positronic
density constant.<br />
The positronic density will be automatically read from a _DEN file (with or
without <a class="wikilink" href="../../input_variables/files/#getden">getden</a>/<a class="wikilink" href="../../input_variables/files/#irdden">irdden</a> keyword).<br />
At the end of the SCF cycle, the positron lifetime and annihilation rate are
printed out.  </li>
</ul>
<p>_Additional information for the use of pseudopotentials:  </p>
<pre><code>* PAW datasets: nothing to do; simply use usual electronic PAW datasets 
* Norm-conserving pseudopotentials: One has to use specific pseudopotentials for the electron calculation. They must be of the FHI type (pspcod=6), and must contain at their end, the all-electrons core density generated with FHI98PP.
</code></pre>
<p>_  </p>
<ul>
<li><strong>Typical use</strong>:<br />
The calculation is done in several steps:<br />
The first one is a normal GS calculation for the electrons, with
<strong>positron</strong>=0. The only specific thing to do is to set <a class="wikilink" href="../../input_variables/files/#prtden">prtden</a>=1 (this is
the defaut for ABINIT v6.x+). This will create the associated _DEN file which
will be used as input file for the positronic GS calculation.<br />
The second step is the GS calculation of the positron and subsequently its
lifetime, with <strong>positron</strong>=1. One has to define also <a class="wikilink" href="../../input_variables/gstate/#ixcpositron">ixcpositron</a>.<br />
Then, it is possible to perform an additional step, computing the GS
electronic density in presence of the positron, with <strong>positron</strong>=2.<br />
and so on...<br />
This procedure can be automated (for PAW only) by the use of a negative value
for <strong>positron</strong>.<br />
At the end, a converged value of the positron lifetime (decomposed in several
contributions) is printed.<br />
See also <a class="wikilink" href="../../input_variables/gstate/#posdoppler">posdoppler</a> keyword for the calculation of Doppler broadening.  </li>
</ul>
<p><em>Negative values for <strong>positron</strong>:</em><br />
<em>For <strong>positron&lt;0</strong>, will perform an automatic calculation of electrons and
positron densities in the two-component DFT context; then will compute
positron lifetime (and annihilation rate).</em>  </p>
<ul>
<li>
<p><strong>positron=-1</strong>:<br />
Starting from scratch, will first perform an usual electronic ground-state
calculation until convergence (controlled by the use of one of the <em>tolerance</em>
keywords).<br />
Then will perform a positronic ground state calculation in presence of the
electrons and ions; then an electronic ground state calculation in presence of
the positron and the ions...<br />
and so on... until the total energy is converged.<br />
The convergence of the total energy of the ions+electrons+positron system is
controlled by the use of the <a class="wikilink" href="../../input_variables/gstate/#postoldfe">postoldfe</a>, <a class="wikilink" href="../../input_variables/gstate/#postoldff">postoldff</a> and <a class="wikilink" href="../../input_variables/gstate/#posnstep">posnstep</a>
input keywords.<br />
With <strong>positron=-1</strong>, at the beginning of each new electronic/positronic step,
the wave functions are unknown.</p>
</li>
<li>
<p><strong>positron=-10</strong>:<br />
Same as <strong>positron=-1</strong> except that the electronic/positronic wave functions
are stored in memory.<br />
Consequently, the total number of iterations to reach the convergence
(diff_Etotal&lt;<a class="wikilink" href="../../input_variables/gstate/#postoldfe">postoldfe</a> or diff_Forces&lt;<a class="wikilink" href="../../input_variables/gstate/#postoldff">postoldff</a>) is smaller.<br />
But, this can increase the total amount of memory needed by the code.</p>
</li>
<li>
<p><strong>positron=-2</strong>:<br />
Same as <strong>positron=-1</strong> except that the two-component DFT cycle is forced to
stop at the end of an electronic step.</p>
</li>
<li>
<p><strong>positron=-20</strong>:<br />
Same as <strong>positron=-10</strong> except that the two-component DFT cycle is forced to
stop at the end of an electronic step.</p>
</li>
</ul>
<p><em>Advice for use:</em><br />
There are two typical cases which have to be differently treated:</p>
<ul>
<li>
<p><strong>A positron in a perfect <em>bulk</em> system</strong>:<br />
In that case, the positron is delocalized in the whole crystal. Its density is
almost zero.<br />
Thus, the "zero density positron limit" has to be used. <a class="wikilink" href="../../input_variables/gstate/#ixcpositron">ixcpositron</a> has to
be choosen accordingly.<br />
In order to have the zero density positron limit it is adviced to follow these
points:<br />
1- Put a small positronic charge (by setting a <a class="wikilink" href="../../input_variables/gstate/#posocc">posocc</a> to a small value)
<strong>OR</strong> use a big supercell.<br />
2- Use only k=gamma wave vector for the positronic calculation.<br />
3- Use the manual procedure in 2 steps: first <strong>positron</strong>=0 and then
<strong>positron</strong>=1; avoid the <strong>positron=2</strong> step and the automatic procedure
(<strong>positron</strong>&lt;0).<br />
In principle, the positron lifetime should converge with the value of
<a class="wikilink" href="../../input_variables/gstate/#posocc">posocc</a> or the size of the supercell.  </p>
</li>
<li>
<p><strong>A positron trapped in a <em>default</em> (vacancy...)</strong>:<br />
In that case, the positron is localized in the default. Its density can be
localized in the simulation cell (provided that the cell is sufficiently
large) and influences the electronic density.<br />
So, it is advised to use the automatic procedure (<strong>positron</strong>&lt;0) or the
manual procedure with several <strong>positron</strong>=0,1,2,1,... steps.<br />
K-points can be used as in usual electronic calculations.<br />
Also note that it is possible to use forces and stresses to perform structural
minimization.  </p>
</li>
</ul>
<p>References:  </p>
<p><strong>[1]</strong> J. Arponen and E. Pajanne, Ann. Phys. (N.Y.) 121, 343 (1979).<br />
<strong>[2]</strong> Boronski and R.M. Nieminen, Phys. Rev. B 34, 3820 (1986).<br />
<strong>[3]</strong> P.A. Sterne and J.H. Kaiser, Phys. Rev. B 43, 13892 (1991).<br />
<strong>[4]</strong> M.J. Puska, A.P. Seitsonen and R.M. Nieminen, Phys. Rev. B 52, 10947 (1994).<br />
<strong>[5]</strong> B. Barbiellini, M.J. Puska, T. Torsti and R.M.Nieminen, Phys. Rev. B 51, 7341 (1994)  </p>
<hr />
<h2 id="posnstep"><strong>posnstep</strong><a class="headerlink" href="#posnstep" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> POSitron calculation: max. Number of STEPs for the two-component DFT<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/positron">positron</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 50<br />
Test list:</p>
<ul>
<li>tutorial:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_3.in" title="Third step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_3.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_4.in" title="Fourth step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_4.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_5.in" title="Fifth step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_5.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_7.in" title="Sixth step (part 2) of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_7.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t07.in" title="Test of the computation of the positron lifetime (using the two-component DFT) within PAW. A cubic box with 4 Al atoms at experimental volume. Low cut-offs,  few k-points. Datasets 2 to 3 use ixcpositron=2 i.e. LDA electron-positron correlation provided by Puska, Seitsonen,  and Nieminen (PRB 52,  10947). Datasets 4 to 5 use ixcpositron=11 i.e. LDA zero positron density limit parametrized by Arponen and Pajanne and fitted by Sterne and Kaiser (PRB 43,  13892). Dataset 1 performs a simple electronic GS calculation and store the density. Dataset 2 performs a positronic GS calculation in presence of the electronic density computed by dataset 1 (positron=1). Dataset 3 performs an electronic GS calculation in presence of the positronic density computed by dataset 2 (positron=2). Dataset 4 performs an automatic electronic/positronic GS calculation without storage of the wave-functions (positron=-1). Dataset 5 performs an automatic electronic/positronic GS calculation with storage of the wave-functions (positron=-10). Each dataset computes the positron lifetime and annihilation rate after the SCF iterations.">tests/v5/Input/t07.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t35.in" title="Test of the computation of the electron-positron Doppler broadening (using the two-component DFT) within PAW. A cubic box with 4 Al atoms at experimental volume. Low cut-offs,  few k-points. Computes the positron lifetime and well as the electron-positron pairs momentum distributions,  after the SCF iterations.">tests/v7/Input/t35.in</a></li>
</ul>
<p>Relevant only when <a class="wikilink" href="../../input_variables/gstate/#positron">positron</a>&lt;0.<br />
Sets the maximum number of electronic/positronic iterations that, when
reached, will cause the two-component DFT SCF cycle to stop.<br />
The code will first compute the electronic ground-state, then the positronic
ground state in the electronic density, then the electronic ground-state in
the positronic density, ...<br />
...until diff_Etotal&lt;<a class="wikilink" href="../../input_variables/gstate/#postoldfe">postoldfe</a> or diff_Forces&lt;<a class="wikilink" href="../../input_variables/gstate/#postoldff">postoldff</a> or the
number of electronic/positronic steps is <a class="wikilink" href="../../input_variables/gstate/#posnstep">posnstep</a>.  </p>
<hr />
<h2 id="posocc"><strong>posocc</strong><a class="headerlink" href="#posocc" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> POSitron calculation: OCCupation number for the positron<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/positron">positron</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1<br />
Test list:</p>
<ul>
<li>tutorial:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_1.in" title="First step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_1.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_2.in" title="Second step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_2.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_3.in" title="Third step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_3.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_4.in" title="Fourth step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_4.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_5.in" title="Fifth step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_5.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_6.in" title="Sixth step (part 1) of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_6.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_7.in" title="Sixth step (part 2) of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_7.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t07.in" title="Test of the computation of the positron lifetime (using the two-component DFT) within PAW. A cubic box with 4 Al atoms at experimental volume. Low cut-offs,  few k-points. Datasets 2 to 3 use ixcpositron=2 i.e. LDA electron-positron correlation provided by Puska, Seitsonen,  and Nieminen (PRB 52,  10947). Datasets 4 to 5 use ixcpositron=11 i.e. LDA zero positron density limit parametrized by Arponen and Pajanne and fitted by Sterne and Kaiser (PRB 43,  13892). Dataset 1 performs a simple electronic GS calculation and store the density. Dataset 2 performs a positronic GS calculation in presence of the electronic density computed by dataset 1 (positron=1). Dataset 3 performs an electronic GS calculation in presence of the positronic density computed by dataset 2 (positron=2). Dataset 4 performs an automatic electronic/positronic GS calculation without storage of the wave-functions (positron=-1). Dataset 5 performs an automatic electronic/positronic GS calculation with storage of the wave-functions (positron=-10). Each dataset computes the positron lifetime and annihilation rate after the SCF iterations.">tests/v5/Input/t07.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t35.in" title="Test of the computation of the electron-positron Doppler broadening (using the two-component DFT) within PAW. A cubic box with 4 Al atoms at experimental volume. Low cut-offs,  few k-points. Computes the positron lifetime and well as the electron-positron pairs momentum distributions,  after the SCF iterations.">tests/v7/Input/t35.in</a></li>
</ul>
<p>Relevant only when <a class="wikilink" href="../../input_variables/gstate/#positron">positron</a>/=0.<br />
Sets the occupation number for the positron. Has to be &lt;=1.<br />
Changing <a class="wikilink" href="../../input_variables/gstate/#posocc">posocc</a> is only useful for bulk calculation when one wants to
perform lifetime computations using a small simulation cell (can avoid the use
of a supercell). It simulates the dispersion of the positron in the whole
crystal.  </p>
<hr />
<h2 id="postoldfe"><strong>postoldfe</strong><a class="headerlink" href="#postoldfe" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> POSitron calculation: TOLerance on the DiFference of total Energy<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/positron">positron</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1e-06 if <a class="wikilink" href="../../input_variables/gstate/#postoldff">postoldff</a>=0,
0.0 otherwise.</p>
<p>Test list:</p>
<ul>
<li>tutorial:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_3.in" title="Third step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_3.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpositron_4.in" title="Fourth step of the tutorial on electron-positron annihilation">tests/tutorial/Input/tpositron_4.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t07.in" title="Test of the computation of the positron lifetime (using the two-component DFT) within PAW. A cubic box with 4 Al atoms at experimental volume. Low cut-offs,  few k-points. Datasets 2 to 3 use ixcpositron=2 i.e. LDA electron-positron correlation provided by Puska, Seitsonen,  and Nieminen (PRB 52,  10947). Datasets 4 to 5 use ixcpositron=11 i.e. LDA zero positron density limit parametrized by Arponen and Pajanne and fitted by Sterne and Kaiser (PRB 43,  13892). Dataset 1 performs a simple electronic GS calculation and store the density. Dataset 2 performs a positronic GS calculation in presence of the electronic density computed by dataset 1 (positron=1). Dataset 3 performs an electronic GS calculation in presence of the positronic density computed by dataset 2 (positron=2). Dataset 4 performs an automatic electronic/positronic GS calculation without storage of the wave-functions (positron=-1). Dataset 5 performs an automatic electronic/positronic GS calculation with storage of the wave-functions (positron=-10). Each dataset computes the positron lifetime and annihilation rate after the SCF iterations.">tests/v5/Input/t07.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t35.in" title="Test of the computation of the electron-positron Doppler broadening (using the two-component DFT) within PAW. A cubic box with 4 Al atoms at experimental volume. Low cut-offs,  few k-points. Computes the positron lifetime and well as the electron-positron pairs momentum distributions,  after the SCF iterations.">tests/v7/Input/t35.in</a></li>
</ul>
<p>Relevant only when <a class="wikilink" href="../../input_variables/gstate/#positron">positron</a>&lt;0.<br />
Sets a tolerance for absolute difference of total energy (of _
ions+electrons+positron _ system) that, when reached, will cause the SCF cycle
to stop before the number of steps is <a class="wikilink" href="../../input_variables/basic/#nstep">nstep</a> or the number of
electronic/positronic steps is <a class="wikilink" href="../../input_variables/gstate/#posnstep">posnstep</a>.  </p>
<p>Can be specified in Ha (the default), Ry, eV or Kelvin, since <strong> toldfe </strong> has
the '<a class="wikilink" href="../../ENERGY/">ENERGY</a>' characteristics.<br />
Only one and only one of <a class="wikilink" href="../../input_variables/gstate/#postoldfe">postoldfe</a> or <a class="wikilink" href="../../input_variables/gstate/#postoldff">postoldff</a> can be set.</p>
<hr />
<h2 id="postoldff"><strong>postoldff</strong><a class="headerlink" href="#postoldff" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> POSitron calculation: TOLerance on the DiFference of Forces<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/positron">positron</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0<br />
Test list:</p>
<ul>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t07.in" title="Test of the computation of the positron lifetime (using the two-component DFT) within PAW. A cubic box with 4 Al atoms at experimental volume. Low cut-offs,  few k-points. Datasets 2 to 3 use ixcpositron=2 i.e. LDA electron-positron correlation provided by Puska, Seitsonen,  and Nieminen (PRB 52,  10947). Datasets 4 to 5 use ixcpositron=11 i.e. LDA zero positron density limit parametrized by Arponen and Pajanne and fitted by Sterne and Kaiser (PRB 43,  13892). Dataset 1 performs a simple electronic GS calculation and store the density. Dataset 2 performs a positronic GS calculation in presence of the electronic density computed by dataset 1 (positron=1). Dataset 3 performs an electronic GS calculation in presence of the positronic density computed by dataset 2 (positron=2). Dataset 4 performs an automatic electronic/positronic GS calculation without storage of the wave-functions (positron=-1). Dataset 5 performs an automatic electronic/positronic GS calculation with storage of the wave-functions (positron=-10). Each dataset computes the positron lifetime and annihilation rate after the SCF iterations.">tests/v5/Input/t07.in</a></li>
</ul>
<p>Relevant only when <a class="wikilink" href="../../input_variables/gstate/#positron">positron</a>&lt;0.<br />
Sets a tolerance for absolute difference of maximum force acting on ions (due
to _ ions+electrons+positron _ system) that, when reached, will cause the SCF
cycle to stop before the number of SCF steps is <a class="wikilink" href="../../input_variables/basic/#nstep">nstep</a> or the number of
electronic/positronic steps is <a class="wikilink" href="../../input_variables/gstate/#posnstep">posnstep</a>.<br />
Only one and only one of <a class="wikilink" href="../../input_variables/gstate/#postoldfe">postoldfe</a> or <a class="wikilink" href="../../input_variables/gstate/#postoldff">postoldff</a> can be set.  </p>
<hr />
<h2 id="prtdensph"><strong>prtdensph</strong><a class="headerlink" href="#prtdensph" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> PRinT integral of DENsity inside atomic SPHeres<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/printing">printing</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1 otherwise.</p>
<p>Test list:</p>
<ul>
<li>tutoparal:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutoparal/Input/tstring_01.in" title="Hydronium ion + NH3 molecule Ground state calculation keeping O and H atoms fixed">tests/tutoparal/Input/tstring_01.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t20.in" title="NiO antiferromagnetic. Test of prtfatbnd==2 2 Ni and 2 O atoms in an fcc supercell. The cut-offs are unrealistic. The aim of this test is to verify: * Computation of band structure in PAW+U * Calculation of partial DOS (diffs of partial DOS is not done) * Calculation of Fatbands (diff of a fatband file is done)">tests/v5/Input/t20.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t37.in" title="Simple test for LDA+U features. 2 Ni and 2 O atoms in an fcc supercell. The cut-offs are unrealistic. The aim of this test is to verify: * Antiferromagnetism and PAW+U * Use of an initial and constant density matrix during the first SCF iterations">tests/v5/Input/t37.in</a></li>
</ul>
<p>When this flag is activated, values of integral(s) of total density inside
sphere(s) around each atom are printed in output file (for each spin
component). Spheres around atoms are defined by a radius given by <a class="wikilink" href="../../input_variables/gstate/#ratsph">ratsph</a>
keyword.<br />
Note: integral of density inside a sphere around an atom can be used to
determine a rough approximation of the local magnetic moment; this is
particularly useful for antiferromagnetic systems.<br />
The algorithm to compute this integral is particularly primitive : the points
on the FFT grids, belonging to the interior of the sphere are determined, and
the value of the functions on these points are summed, taking into account a
fixed volume attributed to each point. In particular, the integral as a
function of the radius will be a constant, except when a new point enters the
sphere, in which case a sudden jump occurs. However, since the purpose of this
output is to get a rough idea of the repartition of the density, this is not a
real problem. If you are interested in a more accurate estimation of the
density within a sphere, you should use the cut3d postprocessor.</p>
<hr />
<h2 id="prtebands"><strong>prtebands</strong><a class="headerlink" href="#prtebands" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> PRinT Electron BANDS<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/printing">printing</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0 if <a class="wikilink" href="../../input_variables/rlx/#nimage">nimage</a> &gt; 1,
1 otherwise.</p>
<p>Test list:</p>
<ul>
<li>libxc:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/libxc/Input/t42.in" title="Diamond: hybrid functional calculation with the GW code Self-consistent approach to the HSE06 band structure based on a unitary transform of a subset of LDA wavefunctions">tests/libxc/Input/t42.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t88.in" title="Calculation of phonon linewidths and e-ph coupling parameter lambda.">tests/v7/Input/t88.in</a></li>
<li>v8:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v8/Input/t04.in" title="Interpolation of electronic bands with two different techniques (star functions and B-spline interpolation)">tests/v8/Input/t04.in</a></li>
</ul>
<p>This option activates the output of the electron eigenvalues. Possible values:</p>
<ul>
<li>0 Disable the output of the band energies.</li>
<li>1 Write eigenvalues in xmgrace format. A file with extension <code>EBANDS.agr</code> is produced at the end of the run. Use <code>xmgrace file_EBANDS.agr</code> to visualize the band energies</li>
<li>2 Write eigenvalues in gnuplot format. The code produces a <code>EBANDS.dat</code> file with the eigenvalues and a <code>EBANDS.gnuplot</code> script. Use <code>gnuplot file_EBANDS.gnuplot</code> to visualize the band energies.</li>
</ul>
<hr />
<h2 id="qpt"><strong>qpt</strong><a class="headerlink" href="#qpt" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Q PoinT<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/q-points">q-points</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> (3)<br />
<em>Default value:</em> [0, 0, 0]  </p>
<p>Only used if <a class="wikilink" href="../../input_variables/gstate/#nqpt">nqpt</a>=1.</p>
<p>Combined with <a class="wikilink" href="../../input_variables/gstate/#qptnrm">qptnrm</a>, define the q vector <a class="wikilink" href="../../input_variables/internal/#qptn">qptn</a>(1:3) in the case
<a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a>=0.</p>
<p>This input variable is not internal (<a class="wikilink" href="../../input_variables/internal/#qptn">qptn</a>(1:3) is used instead), but is
used to echo the value of <a class="wikilink" href="../../input_variables/internal/#qptn">qptn</a>(1:3), with renormalisation factor one.</p>
<hr />
<h2 id="qptnrm"><strong>qptnrm</strong><a class="headerlink" href="#qptnrm" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Q PoinTs NoRMalization<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/q-points">q-points</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1.0<br />
Test list:</p>
<ul>
<li>v3:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t85.in" title="NiTi simple cubic (RockSalt) Metallic. Different mems are zero. The second perturbation does not converge well ! Should be improved.">tests/v3/Input/t85.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t86.in" title="Si diamond Spin-polarized calculation (nspden=2) RF phonon with q=0.5 0 0">tests/v3/Input/t86.in</a></li>
</ul>
<p>Only used if <a class="wikilink" href="../../input_variables/gstate/#nqpt">nqpt</a>=1 and <a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a>=0</p>
<p>Provides re-normalization of <a class="wikilink" href="../../input_variables/gstate/#qpt">qpt</a>. Must be positive, non-zero. The actual q
vector (renormalized) is <a class="wikilink" href="../../input_variables/internal/#qptn">qptn</a>(1:3)= <a class="wikilink" href="../../input_variables/gstate/#qpt">qpt</a>(1:3)/<a class="wikilink" href="../../input_variables/gstate/#qptnrm">qptnrm</a>.</p>
<hr />
<h2 id="qptopt"><strong>qptopt</strong><a class="headerlink" href="#qptopt" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> QPoinTs OPTion<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/q-points">q-points</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0  </p>
<p>Only used if <a class="wikilink" href="../../input_variables/gstate/#nqpt">nqpt</a>=1.</p>
<p>Controls the set up to generate the Q point <a class="wikilink" href="../../input_variables/internal/#qptn">qptn</a>(1:3) to be used for the
specific dataset, either as a shift of k-point grid in ground-state
calculations, or as a stand-alone phonon wavevector.</p>
<p>There are two basic techniques to generate the Q point : either by specifying
it directly, possibly with a renormalisation factor (<a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a>=0), or
extracting it from a grid a Q points (<a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a>=1 to 4), using the index
<a class="wikilink" href="../../input_variables/gstate/#iqpt">iqpt</a>. At variance with the similar generation of k points, only ONE q
point can be used per dataset.</p>
<p>With <a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a>=1 to 4, rely on <a class="wikilink" href="../../input_variables/gstate/#ngqpt">ngqpt</a> or <a class="wikilink" href="../../input_variables/gstate/#qptrlatt">qptrlatt</a>, as well as on
<a class="wikilink" href="../../input_variables/gstate/#nshiftq">nshiftq</a> and <a class="wikilink" href="../../input_variables/gstate/#shiftq">shiftq</a> to set up a q point grid, from which the q point
with number <a class="wikilink" href="../../input_variables/gstate/#iqpt">iqpt</a> will be selected. The values <a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a>=1 to 4 differ by
the treatment of symmetries. Note that the symmetries are recomputed starting
from the values of <a class="wikilink" href="../../input_variables/basic/#rprimd">rprimd</a> <a class="wikilink" href="../../input_variables/basic/#xred">xred</a> and <a class="wikilink" href="../../input_variables/gstate/#spinat">spinat</a>. So, the explicit value
of <a class="wikilink" href="../../input_variables/basic/#symrel">symrel</a> are not used. This is to allow doing calculations with
<a class="wikilink" href="../../input_variables/basic/#nsym">nsym</a>=1, sometimes needed for T-dependent electronic structure, still
decreasing the number of q points in the case <a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a>=1 or <a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a>=3.</p>
<ul>
<li>0=&gt; read directly <a class="wikilink" href="../../input_variables/gstate/#qpt">qpt</a>, and its (eventual) renormalisation factor <a class="wikilink" href="../../input_variables/gstate/#qptnrm">qptnrm</a>. </li>
<li>
<p>1=&gt; Take fully into account the symmetry to generate the grid of q points in the Irreducible Brillouin Zone only. <br />
(This is the usual mode for RF calculations)</p>
</li>
<li>
<p>2=&gt; Take into account only the time-reversal symmetry : q points will be generated in half the Brillouin zone.   </p>
</li>
<li>
<p>3=&gt; Do not take into account any symmetry : q points will be generated in the full Brillouin zone.   </p>
</li>
<li>
<p>4=&gt; Take into account all the symmetries EXCEPT the time-reversal symmetry to generate the k points in the Irreducible Brillouin Zone.   </p>
</li>
</ul>
<p>In the case of a grid of q points, the auxiliary variables <a class="wikilink" href="../../input_variables/gstate/#kptrlen">kptrlen</a>,
<a class="wikilink" href="../../input_variables/basic/#ngkpt">ngkpt</a> and <a class="wikilink" href="../../input_variables/files/#prtkpt">prtkpt</a> might help you to select the optimal grid, similarly
to the case of the K point grid.</p>
<hr />
<h2 id="qptrlatt"><strong>qptrlatt</strong><a class="headerlink" href="#qptrlatt" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Q - PoinTs grid : Real space LATTice<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/q-points">q-points</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (3,3)<br />
<em>Default value:</em> <em>0<br />
</em>The use of this variable forbids the use of:* specified(<a class="wikilink" href="../../input_variables/gstate/#ngqpt">ngqpt</a>)<br />
Test list:</p>
<ul>
<li>v6:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t35.in" title="Generate first-order responses for FCC Aluminum. Very low cut-off,  to keep CPU the lowest possible Aim at a regular sampling of phonon wavevectors,  needed to interpolate the dynamical matrix over the whole Brillouin Zone. Use the definition through qptrlatt. Otherwise,  similar to Tv2#26 and Tv6#78.">tests/v6/Input/t35.in</a></li>
</ul>
<p>This input variable is used only when <a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a> is positive. It partially
defines the q point grid. The other piece of information is contained in
<a class="wikilink" href="../../input_variables/gstate/#shiftq">shiftq</a>. <a class="wikilink" href="../../input_variables/gstate/#qptrlatt">qptrlatt</a> cannot be used together with <a class="wikilink" href="../../input_variables/gstate/#ngqpt">ngqpt</a>.</p>
<p>The values <a class="wikilink" href="../../input_variables/gstate/#qptrlatt">qptrlatt</a>(1:3,1), <a class="wikilink" href="../../input_variables/gstate/#qptrlatt">qptrlatt</a>(1:3,2), <a class="wikilink" href="../../input_variables/gstate/#qptrlatt">qptrlatt</a>(1:3,3) are
the coordinates of three vectors in real space, expressed in the <a class="wikilink" href="../../input_variables/basic/#rprimd">rprimd</a>
coordinate system (reduced coordinates). They defines a super-lattice in real
space. The k point lattice is the reciprocal of this super-lattice, possibly
shifted (see <a class="wikilink" href="../../input_variables/gstate/#shiftq">shiftq</a>).</p>
<p>If neither <a class="wikilink" href="../../input_variables/gstate/#ngqpt">ngqpt</a> nor <a class="wikilink" href="../../input_variables/gstate/#qptrlatt">qptrlatt</a> are defined, ABINIT will automatically
generate a set of k point grids, and select the best combination of
<a class="wikilink" href="../../input_variables/gstate/#qptrlatt">qptrlatt</a> and <a class="wikilink" href="../../input_variables/gstate/#shiftq">shiftq</a> that allows to reach a sufficient value of
<a class="wikilink" href="../../input_variables/gstate/#kptrlen">kptrlen</a>. See this latter variable for a complete description of this
procedure.</p>
<hr />
<h2 id="ratsph"><strong>ratsph</strong><a class="headerlink" href="#ratsph" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Radii of the ATomic SPHere(s)<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/printing">printing</a>, <a class="wikilink" href="../../topics/MagMom">MagMom</a>, <a class="wikilink" href="../../topics/ElecBandStructure">ElecBandStructure</a>, <a class="wikilink" href="../../topics/ElecDOS">ElecDOS</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> (<a class="wikilink" href="../../input_variables/basic/#ntypat">ntypat</a>)<br />
<em>Default value:</em> <a class="wikilink" href="../../'AUTO_FROM_PSP'/">'AUTO_FROM_PSP'</a> if usepaw==1,
2.0 otherwise.</p>
<p>Test list:</p>
<ul>
<li>tutorial:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tpaw1_4.in" title="Input for PAW1 tutorial Diamond at experimental volume">tests/tutorial/Input/tpaw1_4.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorial/Input/tspin_3.in" title="Fe fcc structure with two atoms per unit cell for test of antiferromagnetic This is the simplest fcc structure compatible with a X point spiral">tests/tutorial/Input/tspin_3.in</a></li>
<li>v4:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v4/Input/t35.in" title="One He atom in a big simple cubic box Compute the DOS using the tetrahedron method. Also compute the partial DOS. There is a quite surprising feature of this very simple DOS, that might seem to be due to a bug,  but is NOT one. Indeed,  the obtained DOS is not continuous (vizualize the result of DATASET 2):  at two energies,  there is a small,  but sizeable jump. This feature is associated with a rather sparse sampling of the Brillouin zone. Indeed,  some of the tetrahedra have three corners with perfectly identical energies. Such a set of corners belong to two different tetrahedra. If there is not an equal slope of energy when moving away from each sides of the triangles,  in the different tetrahedra, the DOS is discontinuous at the energy of the three shared corners. (explanation found by M. Verstraete)">tests/v4/Input/t35.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v4/Input/t38.in" title="Test the computation of the partial DOS,  using the linear tetrahedron method. 2 Silicon atoms,  in a diamond structure.">tests/v4/Input/t38.in</a></li>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t20.in" title="NiO antiferromagnetic. Test of prtfatbnd==2 2 Ni and 2 O atoms in an fcc supercell. The cut-offs are unrealistic. The aim of this test is to verify: * Computation of band structure in PAW+U * Calculation of partial DOS (diffs of partial DOS is not done) * Calculation of Fatbands (diff of a fatband file is done)">tests/v5/Input/t20.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t37.in" title="Simple test for LDA+U features. 2 Ni and 2 O atoms in an fcc supercell. The cut-offs are unrealistic. The aim of this test is to verify: * Antiferromagnetism and PAW+U * Use of an initial and constant density matrix during the first SCF iterations">tests/v5/Input/t37.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t04.in" title="Test natsph_extra,  ratsph_extra,  and xredsph_extra for STS calculation. Al (111) surface slab with very low ecut and ngkpt in the plane.">tests/v7/Input/t04.in</a></li>
</ul>
<p>Relevant only when <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a>=3 or <a class="wikilink" href="../../input_variables/gstate/#prtdensph">prtdensph</a>=1.  </p>
<p>When <a class="wikilink" href="../../input_variables/files/#prtdos">prtdos</a>=3:<br />
Provides the radius of the spheres around the <a class="wikilink" href="../../input_variables/gstate/#natsph">natsph</a> atoms of indices
<a class="wikilink" href="../../input_variables/gstate/#iatsph">iatsph</a>, in which the local DOS and its angular-momentum projections will
be analysed. The choice of this radius is quite arbitrary. In a plane-wave
basis set, there is no natural definition of an atomic sphere. However, it
might be wise to use the following well-defined and physically motivated
procedure (in version 4.2, this procedure is NOT implemented, unfortunately) :
from the Bader analysis, one can define the radius of the sphere that contains
the same charge as the Bader volume. This "Equivalent Bader charge atomic
radius" might then be used to perform the present analysis. See the
<a class="wikilink" href="../../help_aim/">help_aim</a> for more explanations. Another physically motivated choice would
be to rely on another charge partitioning, like the Hirshfeld one (see the
cut3d utility). The advantage of using charge partitioning schemes comes from
the fact that the sum of atomic DOS, for all angular momenta and atoms,
integrated on the energy range of the occupied states, gives back the total
charge. If this is not an issue, one could rely on the half of the nearest-
neighbour distances, or any scheme that allows to define an atomic radius.
Note that the choice of this radius is however critical for the balance
between the s, p and d components. Indeed, the integrated charge within a
given radius, behave as a different power of the radius, for the different
channels s, p, d. At the limit of very small radii, the s component dominates
the charge contained in the sphere ...  </p>
<p>When <a class="wikilink" href="../../input_variables/gstate/#prtdensph">prtdensph</a>=1:<br />
Provides the radius of the spheres around (all) atoms in which the total
charge density will be integrated.  </p>
<p>In case of PAW, <a class="wikilink" href="../../input_variables/gstate/#ratsph">ratsph</a> radius has to be greater or equal to PAW radius of
considered atom type (which is read from the PAW dataset file; see rc_sph or
r_paw).</p>
<hr />
<h2 id="ratsph_extra"><strong>ratsph_extra</strong><a class="headerlink" href="#ratsph_extra" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Radii of the ATomic SPHere(s) in the EXTRA set<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/printing">printing</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 2.0 Bohr<br />
Test list:</p>
<ul>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t04.in" title="Test natsph_extra,  ratsph_extra,  and xredsph_extra for STS calculation. Al (111) surface slab with very low ecut and ngkpt in the plane.">tests/v7/Input/t04.in</a></li>
</ul>
<p>Radius for extra spheres the DOS is projected into. See <a class="wikilink" href="../../input_variables/gstate/#natsph_extra">natsph_extra</a> and
<a class="wikilink" href="../../input_variables/gstate/#xredsph_extra">xredsph_extra</a> for the number and positions of the spheres.</p>
<hr />
<h2 id="scphon_supercell"><strong>scphon_supercell</strong><a class="headerlink" href="#scphon_supercell" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Self Consistent PHONon SUPERCELL<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/DFPT">DFPT</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (3)<br />
<em>Default value:</em> [1, 1, 1]<br />
Test list:</p>
<p>Give extent, in number of primitive unit cells, of the supercell being used
for a self-consistent phonon calculation. Presumes the phonon frequencies and
eigenvectors have been calculated in the original primitive unit cell, on a
grid of q-points which corresponds to the supercell in the present
calculation. TO BE IMPROVED : should contain a tutorial on how to do self-
consistent phonon calculations, David Waroquiers 090831</p>
<hr />
<h2 id="scphon_temp"><strong>scphon_temp</strong><a class="headerlink" href="#scphon_temp" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Self Consistent PHONon TEMPerature<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/DFPT">DFPT</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.0<br />
Test list:</p>
<p>Temperature which is imposed on phonon distribution, in the self-consistent
scheme of Souvatzis et al. PRL <strong> 100 </strong> , 095901. Determines the extent of
the finite displacements used, and consequent anharmonic effects.
Experimental.</p>
<hr />
<h2 id="shiftq"><strong>shiftq</strong><a class="headerlink" href="#shiftq" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> SHIFT for Q points<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/q-points">q-points</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> (3,<a class="wikilink" href="../../input_variables/gstate/#nshiftq">nshiftq</a>)<br />
<em>Default value:</em> None if <a class="wikilink" href="../../input_variables/gstate/#nshiftq">nshiftq</a>&gt;1,
[0.5, 0.5, 0.5] otherwise.</p>
<p>Test list:</p>
<ul>
<li>tutorespfn:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorespfn/Input/tdepes_3.in" title="Temperature dependence calculation of diamond.">tests/tutorespfn/Input/tdepes_3.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/tutorespfn/Input/tdepes_4.in" title="Temperature dependence calculation of diamond.">tests/tutorespfn/Input/tdepes_4.in</a></li>
<li>v6:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t35.in" title="Generate first-order responses for FCC Aluminum. Very low cut-off,  to keep CPU the lowest possible Aim at a regular sampling of phonon wavevectors,  needed to interpolate the dynamical matrix over the whole Brillouin Zone. Use the definition through qptrlatt. Otherwise,  similar to Tv2#26 and Tv6#78.">tests/v6/Input/t35.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v6/Input/t78.in" title="Generate first-order responses for FCC Aluminum. Very low cut-off,  to keep CPU the lowest possible Aim at a regular sampling of phonon wavevectors,  needed to interpolate the dynamical matrix over the whole Brillouin Zone. Use the definition through ngqpt and nshiftq. Otherwise,  similar to Tv2#26">tests/v6/Input/t78.in</a></li>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t50.in" title="Diamond. Test temperature-dependent of the electronic structure,  with reduction of the number of q points to be computed,  thanks to thmflag=7 . The temperature-dependent shifts must be averaged over degenerate states. This temperature-dependent calculation make use of a k-point interpolation to speed up the convergence study with respect to the q-points integration. Two q-points are computed.">tests/v7/Input/t50.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t51.in" title="This tests make use of the irdwfkfine variable instead of the getwfkfine variable used in the previous test. The third q-point is computed here.">tests/v7/Input/t51.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t89.in" title="Calculation of e-ph coupling matrix elements">tests/v7/Input/t89.in</a></li>
</ul>
<p>It is used only when <a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a>&gt;=0, and must be defined if <a class="wikilink" href="../../input_variables/gstate/#nshiftq">nshiftq</a> is
larger than 1.<br />
<a class="wikilink" href="../../input_variables/gstate/#shiftq">shiftq</a>(1:3,1:<a class="wikilink" href="../../input_variables/gstate/#nshiftq">nshiftq</a>) defines <a class="wikilink" href="../../input_variables/gstate/#nshiftq">nshiftq</a> shifts of the homogeneous
grid of q points based on <a class="wikilink" href="../../input_variables/gstate/#ngqpt">ngqpt</a> or <a class="wikilink" href="../../input_variables/gstate/#qptrlatt">qptrlatt</a>.</p>
<p>See <a class="wikilink" href="../../input_variables/basic/#shiftk">shiftk</a> for more information on the definition, use, and suitable
values for these shifts.</p>
<hr />
<h2 id="slabwsrad"><strong>slabwsrad</strong><a class="headerlink" href="#slabwsrad" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> jellium SLAB Wigner-Seitz RADius<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Artificial">Artificial</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.0<br />
Test list:</p>
<ul>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t56.in" title="Bulk jellium (the slab fills up the entire cell): computation of the total energy. Tested 3 Wigner-Seitz radii: 1.5,  2 (~aluminum),  4. For each Wigner-Seitz radius the energy per particle agrees with that analytically calculated using the Teter-Pade functional form. The number of k points has been much reduced,  for the purpose of the automatic testing.">tests/v5/Input/t56.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t57.in" title="Jellium slab (50 jellium/ 50 vacuum) with Wigner-Seitz radius=4. Computation of the total energy The number of k points has been much reduced">tests/v5/Input/t57.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t58.in" title="Jellium thin slab with Wigner-Seitz radius=2.56 (~copper) + 1 Na adatom. Computation of the total energy and force on the Na atom. Its position with respect to the slab already is the equilibrium position so the calculation should use only one optimization step.">tests/v5/Input/t58.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t59.in" title="Jellium thin slab with Wigner-Seitz radius=2.56 (~copper) + 1 Na adatom. Computation of the total energy at the Na equilibrium distance from the jellium edge and two other ones,  slightly farther and slightly closer. The total energies should indicate as more stable the equilibrium distance. The number of k points has been much reduced">tests/v5/Input/t59.in</a></li>
</ul>
<p>Fix the bulk-mean positive charge density nbulk of a jellium slab (if the
latter is employed, e.g. <a class="wikilink" href="../../input_variables/gstate/#jellslab">jellslab</a>  0). Often called "rs" [see for example
N. D. Lang and W. Kohn PRB 1, 4555 (1970)], <a class="wikilink" href="../../input_variables/gstate/#slabwsrad">slabwsrad</a> is the radius of a
sphere which has the same volume as the average volume per particle in a
homogeneous electron gas with density nbulk, so:</p>
<pre><code>  1/nbulk = 4/3 Pi * [[slabwsrad]]3
</code></pre>
<p>For example, the bulk aluminum fcc lattice constant is a=4.0495 Angstroms
(webelements.com), each cubic centered cell includes 4 Al atoms and each atom
has 3 valence electrons, so the average volume per electron is a3/12=37.34
Bohr3 which has to be equal to 4/3 Pi*rs3. Consequently Al has approximately
rs =2.07 Bohr, while for example magnesium has rs =2.65 Bohr, sodium 3.99
Bohr.<br />
By default, given in Bohr atomic units (1 Bohr=0.5291772108 Angstroms).</p>
<hr />
<h2 id="slabzbeg"><strong>slabzbeg</strong><a class="headerlink" href="#slabzbeg" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> jellium SLAB BEGinning edge along the Z direction<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Artificial">Artificial</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> [0.0, 0.0]<br />
Test list:</p>
<ul>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t56.in" title="Bulk jellium (the slab fills up the entire cell): computation of the total energy. Tested 3 Wigner-Seitz radii: 1.5,  2 (~aluminum),  4. For each Wigner-Seitz radius the energy per particle agrees with that analytically calculated using the Teter-Pade functional form. The number of k points has been much reduced,  for the purpose of the automatic testing.">tests/v5/Input/t56.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t57.in" title="Jellium slab (50 jellium/ 50 vacuum) with Wigner-Seitz radius=4. Computation of the total energy The number of k points has been much reduced">tests/v5/Input/t57.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t58.in" title="Jellium thin slab with Wigner-Seitz radius=2.56 (~copper) + 1 Na adatom. Computation of the total energy and force on the Na atom. Its position with respect to the slab already is the equilibrium position so the calculation should use only one optimization step.">tests/v5/Input/t58.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t59.in" title="Jellium thin slab with Wigner-Seitz radius=2.56 (~copper) + 1 Na adatom. Computation of the total energy at the Na equilibrium distance from the jellium edge and two other ones,  slightly farther and slightly closer. The total energies should indicate as more stable the equilibrium distance. The number of k points has been much reduced">tests/v5/Input/t59.in</a></li>
</ul>
<p>Define the edges of the jellium slab (if used, so if <a class="wikilink" href="../../input_variables/gstate/#jellslab">jellslab</a>  0) along
z, namely the slab starts at a point along z which is expressed in Bohr by
<strong>slabzbeg</strong> and it ends at a point expressed in Bohr by <a class="wikilink" href="../../input_variables/gstate/#slabzend">slabzend</a>. The z
direction is parallel to the third crystal primitive lattice vector which has
to be orthogonal to the other ones, so the length of the cell along z is
<a class="wikilink" href="../../input_variables/basic/#rprimd">rprimd</a>(3,3). In addition <strong>slabzbeg</strong> and <a class="wikilink" href="../../input_variables/gstate/#slabzend">slabzend</a> have to be such
that:</p>
<pre><code>  0  **slabzbeg** &lt; [[slabzend]]  [[rprimd]](3,3)
</code></pre>
<p>Together with <a class="wikilink" href="../../input_variables/gstate/#slabwsrad">slabwsrad</a> they define the jellium positive charge density
distribution n+(x,y,z) in this way:</p>
<pre><code>  n+(x,y,z) = nbulk     if **slabzbeg**  z  [[slabzend]]
            = 0        otherwise,
</code></pre>
<p>so the positive charge density is invariant along the xy plane as well as the
electrostatic potential generated by it.</p>
<hr />
<h2 id="slabzend"><strong>slabzend</strong><a class="headerlink" href="#slabzend" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> jellium SLAB ENDing edge along the Z direction<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Artificial">Artificial</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> [0.0, 0.0]<br />
Test list:</p>
<ul>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t56.in" title="Bulk jellium (the slab fills up the entire cell): computation of the total energy. Tested 3 Wigner-Seitz radii: 1.5,  2 (~aluminum),  4. For each Wigner-Seitz radius the energy per particle agrees with that analytically calculated using the Teter-Pade functional form. The number of k points has been much reduced,  for the purpose of the automatic testing.">tests/v5/Input/t56.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t57.in" title="Jellium slab (50 jellium/ 50 vacuum) with Wigner-Seitz radius=4. Computation of the total energy The number of k points has been much reduced">tests/v5/Input/t57.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t58.in" title="Jellium thin slab with Wigner-Seitz radius=2.56 (~copper) + 1 Na adatom. Computation of the total energy and force on the Na atom. Its position with respect to the slab already is the equilibrium position so the calculation should use only one optimization step.">tests/v5/Input/t58.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t59.in" title="Jellium thin slab with Wigner-Seitz radius=2.56 (~copper) + 1 Na adatom. Computation of the total energy at the Na equilibrium distance from the jellium edge and two other ones,  slightly farther and slightly closer. The total energies should indicate as more stable the equilibrium distance. The number of k points has been much reduced">tests/v5/Input/t59.in</a></li>
</ul>
<p>Define the edges of the jellium slab (if used, so if <a class="wikilink" href="../../input_variables/gstate/#jellslab">jellslab</a>  0) along
z, namely the slab starts at a point along z which is expressed in Bohr by
<a class="wikilink" href="../../input_variables/gstate/#slabzbeg">slabzbeg</a> and it ends at a point expressed in Bohr by <strong>slabzend</strong>. The z
direction is parallel to the third crystal primitive lattice vector which has
to be orthogonal to the other ones, so the length of the cell along z is
<a class="wikilink" href="../../input_variables/basic/#rprimd">rprimd</a>(3,3). In addition <a class="wikilink" href="../../input_variables/gstate/#slabzbeg">slabzbeg</a> and <strong>slabzend</strong> have to be such
that:</p>
<pre><code>  0  [[slabzbeg]] &lt; **slabzend**  [[rprimd]](3,3)
</code></pre>
<p>Together with <a class="wikilink" href="../../input_variables/gstate/#slabwsrad">slabwsrad</a> they define the jellium positive charge density
distribution n+(x,y,z) in this way:</p>
<pre><code>  n+(x,y,z) = nbulk     if [[slabzbeg]]  z  **slabzend**
            = 0        otherwise,
</code></pre>
<p>so the positive charge density is invariant along the xy plane as well as the
electrostatic potential generated by it.</p>
<hr />
<h2 id="so_psp"><strong>so_psp</strong><a class="headerlink" href="#so_psp" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Spin-Orbit treatment for each PSeudoPotential<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/spinpolarisation">spinpolarisation</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (<a class="wikilink" href="../../input_variables/gstate/#npsp">npsp</a>)<br />
<em>Default value:</em> <a class="wikilink" href="../../input_variables/gstate/#npsp">npsp</a><em>1<br />
</em>Only relevant if:* <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>==2 and <a class="wikilink" href="../../input_variables/internal/#usepaw">usepaw</a>==0  </p>
<p>For each type of atom (each pseudopotential), specify the treatment of spin-
orbit interaction (if <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>==2 and Norm-conserving pseudopotentials
<a class="wikilink" href="../../input_variables/internal/#usepaw">usepaw</a>==0)<br />
If 0 : no spin-orbit interaction, even if <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=2<br />
If 1 : treat spin-orbit as specified in the pseudopotential file.<br />
If 2 : treat spin-orbit in the HGH form (usual form, although not allowed for
all pseudopotentials)<br />
If 3 : treat spin-orbit in the HFN form (Hemstreet-Fong-Nelson) (actually, not
implemented ...).</p>
<p>For typical usage, the default value is OK. If the spin-orbit needs to be
turned off for one atom, 0 might be relevant. Note however, that the code will
stop if <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=2 is used and one of the pseudopotential does not contain
the information about the spin-orbit interaction (this is the case for some
old pseudopotentials). Indeed, for spinorial calculations, turning off the
spin-orbit interaction is unphysical, and also does not save CPU time ... It
should only be done for test purposes</p>
<p>Note that if <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>==1, the spin-orbit cannot be treated anyhow, so the
value of <a class="wikilink" href="../../input_variables/gstate/#so_psp">so_psp</a> is irrelevant. In case <a class="wikilink" href="../../input_variables/internal/#usepaw">usepaw</a>=1, please refer to
<a class="wikilink" href="../../input_variables/paw/#pawspnorb">pawspnorb</a>.</p>
<p>Prior to v5.4, the input variable <strong> so_typat </strong> was used, in place of
<a class="wikilink" href="../../input_variables/gstate/#so_psp">so_psp</a>. Because the values 0 and 1 have been switched between <a class="wikilink" href="../../input_variables/gstate/#so_psp">so_psp</a>
and so_typat, it was dangerous to continue to allow the use of so_typat.</p>
<hr />
<h2 id="spinat"><strong>spinat</strong><a class="headerlink" href="#spinat" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> SPIN for AToms<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/spinpolarisation">spinpolarisation</a>, <a class="wikilink" href="../../topics/crystal">crystal</a>, <a class="wikilink" href="../../topics/MagMom">MagMom</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> [3, '<a class="wikilink" href="../../input_variables/geo/#natrd">natrd</a>'] if <a class="wikilink" href="../../input_variables/geo/#natrd">natrd</a>&lt;<a class="wikilink" href="../../input_variables/basic/#natom">natom</a>,
[3, '<a class="wikilink" href="../../input_variables/basic/#natom">natom</a>'] otherwise.</p>
<p><em>Default value:</em> 0.0  </p>
<p>Gives the initial electronic spin-magnetization for each atom, in unit of
h-bar/2.</p>
<p>Note that if <a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=2, the z-component must be given for each atom, in
triplets (0 0 z-component).<br />
For example, the electron of an hydrogen atom can be spin up (0 0 1.0) or spin
down (0 0 -1.0).</p>
<p>This value is only used to create the first exchange and correlation
potential, and is not used anymore afterwards.<br />
It is not checked against the initial occupation numbers <a class="wikilink" href="../../input_variables/gstate/#occ">occ</a> for each spin
channel.<br />
It is meant to give an easy way to break the spin symmetry, and to allow to
find stable local spin fluctuations, for example : antiferromagnetism, or the
spontaneous spatial spin separation of elongated H2 molecule.  </p>
<ul>
<li>
<p>If the atom manipulator is used, <a class="wikilink" href="../../input_variables/gstate/#spinat">spinat</a> will be related to the preprocessed set of atoms, generated by the atom manipulator. The user must thus foresee the effect of this atom manipulator (see <a class="wikilink" href="../../input_variables/geo/#objarf">objarf</a>). </p>
</li>
<li>
<p>If the atom manipulator is not used, and the symmetries are not specified by the user (<a class="wikilink" href="../../input_variables/basic/#nsym">nsym</a>=0), spinat will be used, if present, to determine the anti-ferromagnetic characteristics of the symmetry operations, see <a class="wikilink" href="../../input_variables/gstate/#symafm">symafm</a>. <br />
In case of collinear antiferromagnetism (<a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=1, <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=1,
<a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=2), these symmetries are used to symmetrize the density.<br />
In case of non-collinear magnetism (<a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=1, <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=1,
<a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=4), they are also used to symmetrize the density. In the latter
case, this strongly constrains the magnetization (imposing its direction). If
the user want to let all degrees of freedom of the magnetization evolve, it is
then recommended to put <a class="wikilink" href="../../input_variables/basic/#nsym">nsym</a>=1.  </p>
</li>
<li>
<p>If the symmetries are specified, and the irreducible set of atoms is specified, the anti-ferromagnetic characteristics of the symmetry operations <a class="wikilink" href="../../input_variables/gstate/#symafm">symafm</a> will be used to generate <a class="wikilink" href="../../input_variables/gstate/#spinat">spinat</a> for all the non-irreducible atoms. </p>
</li>
<li>
<p>In the case of PAW+U calculations using the <a class="wikilink" href="../../input_variables/paw/#dmatpawu">dmatpawu</a> initial occupation matrix, and if <a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=4, <a class="wikilink" href="../../input_variables/gstate/#spinat">spinat</a> is also used to determine the direction of the integrated magnetization matrix. </p>
</li>
</ul>
<hr />
<h2 id="stmbias"><strong>stmbias</strong><a class="headerlink" href="#stmbias" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Scanning Tunneling Microscopy BIAS voltage<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/STM">STM</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.0<br />
Test list:</p>
<ul>
<li>v4:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v4/Input/t46.in" title="5-atom Al slab,  with three vacuum layers. First,  converge the wavefunctions,  then compute the STM charge density below and above the Fermi energy,  within a 2eV range.">tests/v4/Input/t46.in</a></li>
</ul>
<p>Gives, in Hartree, the bias of the STM tip, with respect to the sample, in
order to generate the STM density map.<br />
Used with positive <a class="wikilink" href="../../input_variables/basic/#iscf">iscf</a>, <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>=7 (metallic, gaussian), <a class="wikilink" href="../../input_variables/basic/#nstep">nstep</a>=1 ,
and positive <a class="wikilink" href="../../input_variables/files/#prtstm">prtstm</a>, this value is used to generate a charge density map
from electrons close to the Fermi energy, in a (positive or negative) energy
range. Positive <a class="wikilink" href="../../input_variables/gstate/#stmbias">stmbias</a> will lead to the inclusion of occupied (valence)
states only, while negative <a class="wikilink" href="../../input_variables/gstate/#stmbias">stmbias</a> will lead to the inclusion of
unoccupied (conduction) states only.<br />
Can be specified in Ha (the default), Ry, eV or Kelvin, since <a class="wikilink" href="../../input_variables/gstate/#stmbias">stmbias</a> has
the '<a class="wikilink" href="../../ENERGY/">ENERGY</a>' characteristics (0.001 Ha = 27.2113845 meV = 315.773 Kelvin).
With <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>=7, one has also to specify an independent broadening
<a class="wikilink" href="../../input_variables/gstate/#tsmear">tsmear</a>.</p>
<hr />
<h2 id="symafm"><strong>symafm</strong><a class="headerlink" href="#symafm" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> SYMmetries, Anti-FerroMagnetic characteristics<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/spinpolarisation">spinpolarisation</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (<a class="wikilink" href="../../input_variables/basic/#nsym">nsym</a>)<br />
<em>Default value:</em> <a class="wikilink" href="../../input_variables/basic/#nsym">nsym</a>*1<br />
Test list:</p>
<ul>
<li>v3:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v3/Input/t20.in" title="H diatomic molecule in the antiferromagnetic regime. Different data sets. Test Shubnikov symmetries.">tests/v3/Input/t20.in</a></li>
</ul>
<p>In case the material is magnetic (well, this is only interesting in the case
of antiferromagnetism, collinear or not), additional symmetries might appear,
that change the sign of the magnetization. They have been introduced by
Shubnikov (1951). They can be used by ABINIT to decrease the CPU time, by
using them to decrease the number of k-points.<br />
<a class="wikilink" href="../../input_variables/gstate/#symafm">symafm</a> should be set to +1 for all the usual symmetry operations, that do
not change the sign of the magnetization, while it should be set to -1 for the
magnetization-changing symmetries.<br />
If the symmetry operations are not specified by the user in the input file,
that is, if <a class="wikilink" href="../../input_variables/basic/#nsym">nsym</a>=0, then ABINIT will use the values of <a class="wikilink" href="../../input_variables/gstate/#spinat">spinat</a> to
determine the content of <a class="wikilink" href="../../input_variables/gstate/#symafm">symafm</a>.<br />
The symmetries found as "antiferro magnetic" (<a class="wikilink" href="../../input_variables/gstate/#symafm">symafm</a>=-1) are used to
symmetrize density and magnetization in the following cases:<br />
- antiferromagnetism (<a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=1, <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=1, <a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=2)<br />
- non-collinear magnetism (<a class="wikilink" href="../../input_variables/basic/#nsppol">nsppol</a>=1, <a class="wikilink" href="../../input_variables/gstate/#nspinor">nspinor</a>=1, <a class="wikilink" href="../../input_variables/gstate/#nspden">nspden</a>=4)<br />
In other cases they are not used.</p>
<hr />
<h2 id="timopt"><strong>timopt</strong><a class="headerlink" href="#timopt" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> TIMing OPTion<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Control">Control</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1 if <a class="wikilink" href="../../SEQUENTIAL/">SEQUENTIAL</a>,
0 otherwise.</p>
<p>This input variable allows to modulate the use of the timing routines.</p>
<p>If 0 =&gt; as soon as possible, suppresses all calls to timing routines<br />
If 1 =&gt; usual timing behaviour, with short analysis, appropriate for
sequential execution<br />
If 2 =&gt; close to <a class="wikilink" href="../../input_variables/gstate/#timopt">timopt</a>=1, except that the analysis routine does not
time the timer, appropriate for parallel execution.<br />
If 3 =&gt; close to <a class="wikilink" href="../../input_variables/gstate/#timopt">timopt</a>=1, except that the different parts of the
lobpcg routine are timed in detail.<br />
If 4 =&gt; close to <a class="wikilink" href="../../input_variables/gstate/#timopt">timopt</a>=1, except that the different parts of the
lobpcg routine are timed in detail. A different splitting of lobpcg than for
<a class="wikilink" href="../../input_variables/gstate/#timopt">timopt</a>=-3 is provided.<br />
If -1 =&gt; a full analysis of timings is delivered<br />
If -2 =&gt; a full analysis of timings is delivered, except timing the timer<br />
If -3 =&gt; a full analysis of timings is delivered, including the detailed
timing of the different parts of the lobpcg routine. (this takes time, and is
discouraged for too small runs - the timing would take more time than the run
!). The timer is timed.<br />
If -4 =&gt; a full analysis of timings is delivered, including the detailed
timing of the different parts of the lobpcg routine. A different splitting of
lobpcg than for <a class="wikilink" href="../../input_variables/gstate/#timopt">timopt</a>=-3 is provided (this takes time, and is discouraged
for too small runs - the timing would take more time than the run !). The
timer is timed. The sum of the independent parts is closer to 100% than for
<a class="wikilink" href="../../input_variables/gstate/#timopt">timopt</a>=-3.</p>
<hr />
<h2 id="tl_nprccg"><strong>tl_nprccg</strong><a class="headerlink" href="#tl_nprccg" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> TaiL maximum Number of PReConditionner Conjugate Gradient iterations<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Wavelets">Wavelets</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 30<br />
Test list:</p>
<ul>
<li>bigdft:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t09.in" title="SiH4 molecule with truncated convergence to test the computation of the tail correction (see the tl_radius) parameter in the input file.">tests/bigdft/Input/t09.in</a></li>
</ul>
<p>This variable is similar to <a class="wikilink" href="../../input_variables/gstate/#wvl_nprccg">wvl_nprccg</a> but for the preconditionner
iterations during the tail corrections (see <a class="wikilink" href="../../input_variables/gstate/#tl_radius">tl_radius</a>  ). TO BE IMPROVED :
all tl_<em> and wvl_</em> variables should contain a link to a tutorial, David
Waroquiers 090831.</p>
<hr />
<h2 id="tl_radius"><strong>tl_radius</strong><a class="headerlink" href="#tl_radius" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> TaiL expansion RADIUS<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Wavelets">Wavelets</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.0<br />
Test list:</p>
<ul>
<li>bigdft:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t09.in" title="SiH4 molecule with truncated convergence to test the computation of the tail correction (see the tl_radius) parameter in the input file.">tests/bigdft/Input/t09.in</a></li>
</ul>
<p>In the wavelet computation case, the linkage between the grid and the free
boundary conditions can be smoothed using an exponential decay. This means a
correction on the energy at the end on each wavefunction optimisation run. If
this parameter is set to zero, no tail computation is done. On the contrary,
put it to a positive value makes the tail correction available. The value
correspond to a length in atomic units being the spacial expansion with the
exponential decay around the grid.</p>
<hr />
<h2 id="tphysel"><strong>tphysel</strong><a class="headerlink" href="#tphysel" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Temperature (PHYSical) of the ELectrons<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/BandOcc">BandOcc</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.0<br />
Test list:</p>
<ul>
<li>v5:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v5/Input/t80.in" title="Test tphysel input,  which convolutes a physical temperature (tphysel) dependence with an artificial cold-smearing (Marzari) to further improve k-point convergence. Physical T dependence should be preserved,  while k-point convergence is sped up.">tests/v5/Input/t80.in</a></li>
</ul>
<p>Gives, in Hartree, the physical temperature of the system, in case
<a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>=4, 5, 6, or 7.<br />
Can be specified in Ha (the default), Ry, eV or Kelvin, since <strong> ecut </strong> has
the '<a class="wikilink" href="../../ENERGY/">ENERGY</a>' characteristics (0.001 Ha = 27.2113845 meV = 315.773 Kelvin).
One has to specify an independent broadening <a class="wikilink" href="../../input_variables/gstate/#tsmear">tsmear</a>. The combination of
the two parameters <a class="wikilink" href="../../input_variables/gstate/#tphysel">tphysel</a> and <a class="wikilink" href="../../input_variables/gstate/#tsmear">tsmear</a> is described in a paper by M.
Verstraete and X. Gonze, Phys. Rev. B 65, 035111 (2002). Note that the
signification of the entropy is modified with respect to the usual entropy.
The choice has been made to use <a class="wikilink" href="../../input_variables/gstate/#tsmear">tsmear</a> as a prefactor of the entropy, to
define the entropy contribution to the free energy.</p>
<hr />
<h2 id="tsmear"><strong>tsmear</strong><a class="headerlink" href="#tsmear" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> Temperature of SMEARing<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/BandOcc">BandOcc</a>, <a class="wikilink" href="../../topics/STM">STM</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0.01  </p>
<p>Gives the broadening of occupation numbers <a class="wikilink" href="../../input_variables/gstate/#occ">occ</a>, in the metallic cases
(<a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>=3, 4, 5, 6 and 7). Can be specified in Ha (the default), eV, Ry,
or Kelvin, since <a class="wikilink" href="../../input_variables/gstate/#tsmear">tsmear</a> has the '<a class="wikilink" href="../../ENERGY/">ENERGY</a>' characteristics (0.001 Ha =
27.2113845 meV = 315.773 Kelvin).<br />
Default is 0.01 Ha. This should be OK using gaussian like smearings (occopt
4,5,6,7) for a free-electron metal like Al. For d-band metals, you may need to
use less.<br />
Always check the convergence of the calculation with respect to this
parameter, and simultaneously, with respect to the sampling of k-points (see
<a class="wikilink" href="../../input_variables/basic/#nkpt">nkpt</a>)<br />
If <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>=3, <a class="wikilink" href="../../input_variables/gstate/#tsmear">tsmear</a> is the physical temperature, as the broadening is
based on Fermi-Dirac statistics. However, if <a class="wikilink" href="../../input_variables/basic/#occopt">occopt</a>=4, 5, 6, or 7, the
broadening is not based on Fermi-Dirac statistics, and <a class="wikilink" href="../../input_variables/gstate/#tsmear">tsmear</a> is only a
convergence parameter. It is still possible to define a physical temperature,
thanks to the input variable <a class="wikilink" href="../../input_variables/gstate/#tphysel">tphysel</a>. See the paper by M. Verstraete and
X. Gonze, Phys. Rev. B (2002).</p>
<hr />
<h2 id="usekden"><strong>usekden</strong><a class="headerlink" href="#usekden" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> USE Kinetic energy DENsity<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/xc">xc</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0  </p>
<p>If <a class="wikilink" href="../../input_variables/gstate/#usekden">usekden</a>=1 the kinetic energy density will be computed during the self-
consistency loop, in a way similar to the computation of the density. This is
needed if a meta-GGA is to be used as XC functional. Otherwise
(<a class="wikilink" href="../../input_variables/gstate/#usekden">usekden</a>=0), the kinetic energy density is not computed during the self-
consistency loop.</p>
<hr />
<h2 id="vacuum"><strong>vacuum</strong><a class="headerlink" href="#vacuum" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> VACUUM identification<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/k-points">k-points</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (3)<br />
<em>Default value:</em> None  </p>
<p>Establishes the presence (if 1) or absence (if 0) of a vacuum layer, along the
three possible directions normal to the primitive axes.</p>
<p>This information might be used to generate k-point grids, if <a class="wikilink" href="../../input_variables/basic/#kptopt">kptopt</a>=0 and
neither <a class="wikilink" href="../../input_variables/basic/#ngkpt">ngkpt</a> nor <a class="wikilink" href="../../input_variables/gstate/#kptrlatt">kptrlatt</a> are defined (see explanations with the
input variable <a class="wikilink" href="../../input_variables/files/#prtkpt">prtkpt</a>).<br />
It will allow to select a zero-, one-, two- or three-dimensional grid of k
points. The coordinate of the k points along vacuum directions is
automatically set to zero.</p>
<p>If <a class="wikilink" href="../../input_variables/gstate/#vacuum">vacuum</a> is not defined, the input variable <a class="wikilink" href="../../input_variables/gstate/#vacwidth">vacwidth</a> will be used to
determine automatically whether the distance between atoms is sufficient to
have the presence or absence of vacuum.</p>
<hr />
<h2 id="vacwidth"><strong>vacwidth</strong><a class="headerlink" href="#vacwidth" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> VACuum WIDTH<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/k-points">k-points</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 10.0<br />
Test list:</p>
<ul>
<li>v2:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v2/Input/t58.in" title="Test the mechanism for checking the presence of vacuum. Use H2 molecule,  placed in a big box.">tests/v2/Input/t58.in</a></li>
</ul>
<p>Give a minimum "projected" distance between atoms to be found in order to
declare that there is some <a class="wikilink" href="../../input_variables/gstate/#vacuum">vacuum</a> present for each of the three
directions. By default, given in Bohr atomic units (1 Bohr=0.5291772108
Angstroms), although Angstrom can be specified, if preferred, since
<a class="wikilink" href="../../input_variables/gstate/#vacwidth">vacwidth</a> has the '<a class="wikilink" href="../../LENGTH/">LENGTH</a>' characteristics.<br />
The precise requirement is that a slab of width <a class="wikilink" href="../../input_variables/gstate/#vacwidth">vacwidth</a>, delimited by two
planes of constant reduced coordinates in the investigated direction, must be
empty of atoms.</p>
<hr />
<h2 id="wtq"><strong>wtq</strong><a class="headerlink" href="#wtq" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> WeighTs for the current Q-points<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/q-points">q-points</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 1<br />
<em>Comment:</em> Except when <a class="wikilink" href="../../input_variables/gstate/#qptopt">qptopt</a>/=0<br />
Test list:</p>
<ul>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t57.in" title="Diamond. The wtq variable is introduced to be able to reproduce the q-point weight obtained with ngqpt and qptopt. The main reason being that the initialization of large q-point (same for k-point) grid is extremely slow. Inputing manually the qpt and wtq in the input file avoid such inefficient initialization.">tests/v7/Input/t57.in</a></li>
</ul>
<p>Gives the current q-point weight.</p>
<hr />
<h2 id="wvl_bigdft_comp"><strong>wvl_bigdft_comp</strong><a class="headerlink" href="#wvl_bigdft_comp" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> WaVeLet BigDFT Comparison<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Wavelets">Wavelets</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 0  </p>
<p>This variable is used for the wavelets capabilities of ABINIT (see <a class="wikilink" href="../../input_variables/basic/#usewvl">usewvl</a>
). It is used to compare the results obtained with ABINIT with those obtained
with BigDFT stand-alone. When it is set to 1, ABINIT will follow the workflow
as in BigDFT stand-alone. Therefore, the results must be exactly the same with
the two codes.</p>
<hr />
<h2 id="wvl_crmult"><strong>wvl_crmult</strong><a class="headerlink" href="#wvl_crmult" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> WaVeLet Coarse grid Radius MULTiplier<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Wavelets">Wavelets</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 6.0  </p>
<p>This factor is used to defined the expansion of the coarse resolution grid in
the case of wavelets (seea <a class="wikilink" href="../../input_variables/basic/#usewvl">usewvl</a> ). The grid is made of points inside
spheres centered on atoms. The radius of these spheres are the product between
this factor and the covalent radius of element (read from the pseudo-potential
file).<br />
This factor is responsible for the amount of used memory (see also
<a class="wikilink" href="../../input_variables/basic/#wvl_hgrid">wvl_hgrid</a>).</p>
<hr />
<h2 id="wvl_frmult"><strong>wvl_frmult</strong><a class="headerlink" href="#wvl_frmult" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> WaVeLet Fine grid Radius MULTiplier<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Wavelets">Wavelets</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 10.0  </p>
<p>This factor is used to defined the expansion of the fine resolution grid in
the case of wavelets (see <a class="wikilink" href="../../input_variables/basic/#usewvl">usewvl</a> ). This fine resolution grid has the same
grid step than the coarse one (see <a class="wikilink" href="../../input_variables/gstate/#wvl_crmult">wvl_crmult</a> ), but on each point, 8
coefficients are stored instead of one, increasing the precision of the
calculation in this area. The grid is made of points inside spheres centered
on atoms. The radius of these spheres are the product between this factor and
a value read from the pseudo-potential file.<br />
This factor is responsible for the amount of used memory (see also
<a class="wikilink" href="../../input_variables/basic/#wvl_hgrid">wvl_hgrid</a>).</p>
<hr />
<h2 id="wvl_ngauss"><strong>wvl_ngauss</strong><a class="headerlink" href="#wvl_ngauss" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> WaVeLet Number of GAUSSians<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Wavelets">Wavelets</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> (2)<br />
<em>Default value:</em> [1, 100]<br />
Test list:</p>
<ul>
<li>bigdft:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t32.in" title="H in a box (PAW). PAW projectors are fitted to Gaussians.">tests/bigdft/Input/t32.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t33.in" title="O2 in a box (NC). ABINIT routines are used (wvl_bigdft_comp=0) Test: DIIS,  potential/density mixing">tests/bigdft/Input/t33.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft/Input/t34.in" title="CO2 in a box (PAW). ABINIT routines are used (wvl_bigdft_comp=0) Test: DIIS mixing.">tests/bigdft/Input/t34.in</a></li>
<li>bigdft_paral:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft_paral/Input/t01.in" title="O2 in a box (NC). ABINIT routines are used (wvl_bigdft_comp=0) Test: DIIS,  potential/density mixing and parallelism">tests/bigdft_paral/Input/t01.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft_paral/Input/t01.in" title="O2 in a box (NC). ABINIT routines are used (wvl_bigdft_comp=0) Test: DIIS,  potential/density mixing and parallelism">tests/bigdft_paral/Input/t01.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft_paral/Input/t02.in" title="CO2 in a box (PAW). ABINIT routines are used (wvl_bigdft_comp=0) Test: DIIS,  density mixing">tests/bigdft_paral/Input/t02.in</a>, <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/bigdft_paral/Input/t02.in" title="CO2 in a box (PAW). ABINIT routines are used (wvl_bigdft_comp=0) Test: DIIS,  density mixing">tests/bigdft_paral/Input/t02.in</a></li>
</ul>
<p>In the wavelet-PAW computation case, projectors may be fitted to a sum of
complex Gaussians. The fit is done for wvl_ngauss(1), wvl_ngauss(1)+1 ... up
to wvl_ngauss(2) Gaussians.</p>
<hr />
<h2 id="wvl_nprccg"><strong>wvl_nprccg</strong><a class="headerlink" href="#wvl_nprccg" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> WaVeLet maximum Number of PReConditionner Conjugate Gradient iterations<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/Wavelets">Wavelets</a><br />
<em>Variable type:</em> integer<br />
<em>Dimensions:</em> scalar<br />
<em>Default value:</em> 5  </p>
<p>In the wavelet computation case, the wavefunctions are directly minimised
using a real-space preconditionner. This preconditionner has internally some
conjugate gradient iterations. This value defines a boundary for the number of
conjugate gradient iterations on each wavefunction convergence step.</p>
<hr />
<h2 id="xredsph_extra"><strong>xredsph_extra</strong><a class="headerlink" href="#xredsph_extra" title="Permanent link">&para;</a></h2>
<p><em>Mnemonics:</em> X(position) in REDuced coordinates of the SPHeres for dos projection in the EXTRA set<br />
<em>Mentioned in topic(s):</em> <a class="wikilink" href="../../topics/printing">printing</a><br />
<em>Variable type:</em> real<br />
<em>Dimensions:</em> (3,<a class="wikilink" href="../../input_variables/gstate/#natsph_extra">natsph_extra</a>)<br />
<em>Default value:</em> <em>0.0<br />
</em>Only relevant if:* <a class="wikilink" href="../../input_variables/gstate/#natsph_extra">natsph_extra</a> &gt; 0<br />
Test list:</p>
<ul>
<li>v7:  <a class="wikilink" data-placement="auto bottom" data-toggle="popover" data-trigger="hover" href="../../tests/v7/Input/t04.in" title="Test natsph_extra,  ratsph_extra,  and xredsph_extra for STS calculation. Al (111) surface slab with very low ecut and ngkpt in the plane.">tests/v7/Input/t04.in</a></li>
</ul>
<p>The positions in reduced coordinates of extra spheres used in the DOS
projection, simulating an STS signal. See <a class="wikilink" href="../../input_variables/gstate/#natsph_extra">natsph_extra</a> for a more complete
description.</p>
<hr />

  <br>
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../gw/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../gw/" class="btn btn-xs btn-link">
        GW
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../geo/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../geo/" class="btn btn-xs btn-link">
        Geometry
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
<hr>

    <center>Abinit version 8.5.4</center>


    <center>Copyright &copy; 2017 The Abinit Group</center>


<center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
</footer>

</body>
</html>